## Python Интересные вопросы. Часть 2 

### Спец метод `__getitem__(self, key)`
Метод отрабатывает когда мы обращаемся к обьекту как к элементу списка,
по индекусу, примеру так:

    from string import ascii_letters

    class MyContainer(object):

        def __getitem__(self, key):
            print('key = ', key)
            return ascii_letters[key]

    my_container = MyContainer()
    
    print(my_container[0])  # выведет a
    print(my_container[16])  # выведет q
    print(my_container[:])  # выведет все элементы

    // Вывод
    key =  0
    a

    key =  16
    q

    key =  slice(None, None, None)
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

Переменная из `ascii_letters` содержит в себе все буквы алфавита.

### Итераторы, Выражения-генераторы, 
Генератор - Это генератор, элементы которого можно перебирать только 1 раз.

Итератор - Это обьект, который поддерживает функцию `next` для перехода 
к след элементу коллекции.  

Итерируемые обьекты - Это обьект,оторый позволяет поочередно обойти свои 
элементы и может быть преобразован к итератору.

Для создания генератора можно использовать 2 способа:

1) Для этого можно использовать уже существующую последовательность, 
к примеру список, при помощи функции `iter()` создаем итерируемый обьект
   и при помощи функции `next()` проходимся по его элементам, каждый раз 
   при вызове функции `next()` она будет вызывать следующий элемент 
   итерируемого обьекта, и не может вернуться назад, при вызове большего
   количества чем содержится в итераторе раз, это даст ошибку:
   

    lt1 = [1, 2, 3]
    
    it = iter(lt1)
    print(it)

    print(next(it))
    print(next(it))
    print(next(it))

    // Вывод
    <list_iterator object at 0x7f248ee9ccf8>
    1
    2
    3

2) Второй способ это создать выражение-генератор, выглядит также как и 
генерация списков, но с круглыми скобками, это создаст генератор, по 
   которому можно будет пройтись уже без использования функции `next()`
   а прсото вызывая его элементы последовательно:


    lt2 = (element for element in range(1000))

    for elem in lt2:
        print(elem)
        if elem >= 100:
            break
          
    for elem in lt2:
        print(elem)
        if elem >= 200:
            break

В качестве вывода увидим числа от 0 до 100 и от 100 до 200, еслибы мы 
использовали списки то повторный вызов цикла вывел бы первые 100 элементов 
повторно, но итераторы проходятся только 1 раз и не более того, так что 
вызов второго цикла приведет к выводу элементов с 100 до 200.

Зачем нужны итераторы или выражения генераторы ?

Дело в том что итераторы не хранят в памяти сразу все свои значения, а 
генерируют их по мере необходимости, при обращении к следующему элементу,
так что така запись создания списка 
`my_list = [elem for elem in range(10000000000000)]` сожрет всю память, в то
время как создание генератора такого типа 
`my_generator = (elem for elem in range(10000000000000))`
создаст генератор который будет генерировать кождое новое значение при 
обращении к нему.

### Функции-генераторы
Используются для экономии занимаемой памяти, это по сути все теже самые
итераторы, представим что у нас есть функция которая возвращает список 
из 100 элементов:

    def get_number():
        return list(range(100))

    x = get_number()
    print(x.__sizeof__())

Эта функция занимает 984 байт при том что формирует список из 100 чисел.

При помощи спец оператора `yield` мы указываем какую переменную следует 
сделать значением итератора, которую этот итератор будет перебирать 
значения это переменной при каждой итерации методом `next()`

    def get_yield_number():
        for x in range(100):
            yield x
        print('Это никогда не будет выведено ')

    s = get_yield_number()

    print('Функция-генератор: ', s)
    print('Память функции-генератора: ', s.__sizeof__())

    print(next(s))
    print(next(s))
    print(next(s))

В функции мы создаем цикл в котоом генерируем последовательность, и при 
помощи оператора `yield` указываем возвращаемое значение, именно это 
значение и будет возвращаться каждый раз когда мы будем вызывать 
следующую итерацию этой функции методом `next()`

В результате вывода видим, что функция использующая оператор `yield` 
становится обьектом генератором, и при помощи перебора методом `next()`
мы можем вызвать в все элементы последовательности из функции, и при 
всем этом благодаря тому что список не хранится в памяти а генерирует 
значение при обращении к нему, занимаемая память будет всего 64 байта.

      Функция-генератор:  <generator object func1.<locals>.get_yield_number at 0x7f0605c4fdb0>
      Память функции-генератора:  64
      0
      1
      2
      3
















