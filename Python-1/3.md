## Python Интересные вопросы. Часть 3

### Декораторы из функций
Декораторы - срабатывают раньше чем сама функция которая ими обернута, 
так что если в декораторе есть вывод чегото в терминал, то оно будет
выведено на экран раньше чем обернутая ими функция.

Функции в питоне это обьекты, их можно передавать как аргументы, 
механизм декораторов это передача функции которую мф хотим исполнить 
в другую функцию в качестве аргумента.

Обычный декоратор:

    def Decorator1(func):
        def wrapper(*args):
            func(*args)
        return wrapper

    @Decorator1
    def func1(x, y):
        print(f'func1 x = {x} y = {y}')

    func1(10, 20)

    // Вывод
    func1 x = 10 y = 20

Указывая декоратор `@Decorator1` мы тем самым вызываем в работу 
функцию `Decorator1` эта функция принимает в качестве аргумента 
функцию `func1()` и в нутри себя создает еще одну функцию обертку 
`wrapper(*args)` здесь аргументы *args являются теми самыми аргументами
`10, 20` которые получила первонаяальная функция, и уже в нутри функции 
обертки `wrapper()` мы можем вызвать на исполнения функцию `func1()`

Декоратор с аргументами:

По мимо обычной работы мы можем еще создать 
декоратор который сам по себе принимает аргументы и работает с ними,
для этогго требуется сделать еще одну вложенность:

    def Decorator1(input_arg):
        def the_real_decorator(func):
            def wrapper(*args):
                result = func(*args)
                return f'input_arg={input_arg} '+result
            return wrapper
        return the_real_decorator


    @Decorator1(55)
    def func1(x, y):
        # print(f'func1 x = {x} y = {y}')
        return f'func1 x = {x} y = {y}'

    print(func1(10, 20))

    // Вывод
    input_arg=55 func1 x = 10 y = 20

Создадим ужу одну функцию обертку `Decorator1(input_arg):` по верх всех 
теех что уже были, гек аргумент `input_arg` и будет нашим аргументом 
декоратора, адалее просто по вложенности возвращаем из функции 
внутренею функцию.

### Декоратор из класса без аргументов
ля реализации декоратора из класса, этот класс должен быьб callable
тоетсь доступен для вызова как функция, что возможнотолько при определении
в этом классе магического метода `__call__`

Декораторы из классов, делаются по такойже методике, тоесть есть 2 или 3 
функции для обертки, только теперь в качестве оберток будут выступать 
методы класса.

Это делается через методы `__init__() __call__()` метод `__init__()`
принимает функцию а метод `__call__()` аргументы функции, и возвращает 
результат работы функции.

Тоесть у нас сразуже создается экземпляр класса нашего декоратора и за ним
этот обьект декоратора вызывается как функция.

    class MyDecorator:

        def __init__(self, function):
            self._function = function

        def __call__(self, *args, **kwargs):
            return self._function(*args, **kwargs)

    @MyDecorator
    def function(a, b):
        return a * b

    print(function(2, 5))

    // Вывод
    10

### Декоратор из класса с аргументами
Методика таже самая только теперь у нас 3 обертки, метод
`__init__(decorator_arg)` принимает аргументы самого декоратора, метод
`__call__(function)` принимает функцию которую мы оборачиваем декоратором,
и в методе `__call__` создаем еще одну обертку котора и будет принимать 
аргументы самой функции `wrapper(*args, **kwargs)` и эу эта непосредственная
обертка и выполняет работу с функцией.

        class MyDecorator:

        def __init__(self, decorator_arg):
            self._decorator_arg = decorator_arg
            self._function = None

        def __call__(self, function):
            self._function = function

            def wrapper(*args, **kwargs):
                result = self._function(*args, **kwargs)
                return f'{self._decorator_arg} {result}'
            return wrapper

    @MyDecorator('Р е з у л ь т а т : ')
    def function(a, b):
        return a * b

    print(function(10, 5))

    // Вывод
    Р е з у л ь т а т :  50

### Функция enumerate
Что такое цикл `for` ? по сути своего механизма этот цикл работает с 
переданной в него последовательностью как с итератором, когда у нас есть 
последовательность и мы передаем ее в цикл, то сам цикл работает со ссылкой 
на индекс последовательности.

Изменения этого значения не дает изменения значений в списке, заменяется
лишь переменная в которой содержится ссылка: 

    ml_1 = [1, 2, 3, 4, 5]
    print(f'Список до : {ml_1}')

    for element in ml_1:
        element = '+'

    print(f'Список после : {ml_1}')

    Список до : [1, 2, 3, 4, 5]
    Список после : [1, 2, 3, 4, 5]

Для того чтобы получить доступ к самим значениям, требуется использовать 
доступ по индексу, это можно сделать так:

    ml_2 = [1, 2, 3, 4, 5]
    print(f'Список до : {ml_2}')

    for iter in range(len(ml_2)):
        ml_2[iter] = '+'

    print(f'Список после : {ml_2}')

    Список до : [1, 2, 3, 4, 5]
    Список после : ['+', '+', '+', '+', '+']

По сути тут мы генерируем последовательность, которая по своим 
значениям будет соответствовать индексам последовательности.

Также можно использовать класс `enumerate()` который принимает 
последовательность, и возвращает кортеж из индекса и значения
последовательности, и по этому индексу будем иметь доступ к списку,
и можем менять его:

    ml_3 = [1, 2, 3, 4, 5]
    print(f'Список до : {ml_3}')

    for iter, value in enumerate(ml_3):
        print(f'{iter} = {value} || ml_3[{iter}] = {ml_3[iter]}')

    print(f'Список после : {ml_3}')

    Список до : [1, 2, 3, 4, 5]
    0 = 1 || ml_3[0] = 1
    1 = 2 || ml_3[1] = 2
    2 = 3 || ml_3[2] = 3
    3 = 4 || ml_3[3] = 4
    4 = 5 || ml_3[4] = 5
    Список после : [1, 2, 3, 4, 5]












