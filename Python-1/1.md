## Python Интересные вопросы. Часть 1

### Доступ к приватным атрибутам и методам обьекта
Если атрибут принадлежит обьекту и является приватным то в атрибуте 
`__dict__` нему можно иметь доступ так:

    pt = Point()
    pt._Point__private

Но что дело до приватных методов ? тут на самом дела все также обстоит,
есть 2 метода один приватный другой публичный, приставка в виде одного 
underscore и названия Класса, поскольку каждый метод является по дефолту
статичным, то увидеть его можно в атрибуте `__dict__` принадлежащем 
классу а не обьекту:

    class Point:
        def __init__(self, one, two):
            self._list = one
            self.__private = two

        def my_public_method(self):
            print('Публичный методв')

        def __my_private_method(self):
            print('Приватный методв')

    pt = Point([10, 20, 30], "Приватная переменная")

    Point.my_public_method(pt)
    Point._Point__my_private_method(pt)

    print(pt.__dict__)
    print('='*20)
    print(Point.__dict__)
 
Вывод:

    Публичный методв
    Приватный методв
    {'_list': [10, 20, 30], '_Point__private': 'Приватная переменная'}
    ====================
    {
    'my_public_method': 
        <function func6.<locals>.Point.my_public_method at 0x7fd3471f1d90>, 
    
    '_Point__my_private_method': 
        <function func6.<locals>.Point.__my_private_method at 0x7fd3471f1e18>,
    }

Тут есть оба метода и как ожидалось приватный скрыт с помощью 
специального префикса.

### List comprehensions
Или просто генераторы списков, это они и есть, обычно он используется для 
генерации списков, но его можно использовать и для генерации всех 
остальных структур данных, кроме кортежей:

    list1 = [elem for elem in range(1, 25, 2)]
    print(f'Тип: {type(list1)}  Содержимое: {list1}')

    # Это уже не кортеж а генератор
    tuple1 = (elem for elem in range(1, 11))
    tuple1 = tuple(tuple1)
    print(f'Тип: {type(tuple1)}  Содержимое: {tuple1}')

    set1 = {elem for elem in range(1, 11)}
    print(f'Тип: {type(set1)}  Содержимое: {set1}')

    dict1 = {elem: elem for elem in range(1, 11)}
    print(f'Тип: {type(dict1)}  Содержимое: {dict1}')

Для этого достаточно прсото указывать нужные скобочки, и в случае с словарями
указывать 2 элемента.

При указании круглых скобок будет создан не кортеж а генератор,сли вызвать 
его то так и увидим его : 

    <generator object func5.<locals>.<genexpr> at 0x7f97b74a3af0>

Тоесть такая генерация пригодна для создания всех структур данных, кроме 
кортежей ибо это уже будет создание не кортежей а создание генератора.

### Ключи для словарей
В качестве ключей для словарей можно использовать только неизменяемые 
типы данных, строки, числа и кортежи, но при условии что кортежи содеражт 
в себе только неизменяемые типы данных:

    ml = {"one": 10, "two": 20, 3: 30, (1, 3): 40}

    print(ml)
    print("ml['one'] = ", ml['one'])
    print("ml[3]12  ё = ", ml[3])
    print("ml[(1, 3)] = ", ml[(1, 3)])

    
    // Вывод
    {'one': 10, 'two': 20, 3: 30, (1, 3): 40}
    ml['one'] =  10
    ml[3] =  30
    ml[(1, 3)] =  40

Если используем числа, то так и пишим числа, если кортежи то так кортежи 
и записываем.

### Отсутствие настоящей защищенности/приватности в Python
Обычно существует 3 модификатора доступа к атрибутам обьектов,
публичный используется по дефолту, один underscore делает атрибут 
защищенным, и 2 underscore дают приватность.

protected - не дает какого либо ограничения на доступ к атрибутам, 
защищенность здесь номинальная, существует лишь как соглашение среди
программистов,  не дает настоящей приватности.

private - тут есть настоящий механизм защиты атрибутов от внешнего 
доступа, но есть одна хитрость.

Допустим есть такой класс:

    class Point:
        def __init__(self, x, y):
            self.x = x
            self._y = y

    pt = Point(10, 20)

    print("Point.__dict__ = ", Point.__dict__)
    print("pt.__dict__ = ", pt.__dict__)

Мы можем вывести атрибуты как обьекта так и класса, именно их спец атрибут 
`__dict__` который в виде словаря хранит в себе все атрибуты.

У самого класса и у обьекта есть свои экземпляры этого атрибута.

Когда мы выводим `__dict__` обьекта, то можем увидеть в нем наши атрибуты 
что мы задали при инициализации нового обьекта класса:
    
    pt.__dict__ =  {'x': 10, '_y': 20}

Видим что все атрибуты тут и перечислены, что публичные что защищенные, 
разница лишь в одном нижнем подчеркивании, теперь можно понять почему нету 
способа защиты от для protected атрибутов.

Добавим в наш класс новый атрибут `__z` и сделаем ее приватной, тогда выведя 
`__dict__` можно увидеть следующие:

    class Point:
        def __init__(self, x, y, z):
            self.x = x
            self._y = y
            self.__z = z

    pt = Point(10, 20, 30)
    print("pt.__dict__ = ", pt.__dict__)

    // Вывод
    pt.__dict__ =  {'x': 10, '_y': 20, '_Point__z': 30}

Мы назвали наш приватный атрибут как `__z` но в итоге видим как появилсяатрибут 
`_Point__z` и уже вызвав этот атрибут мы можем получить к нему доступ, даже 
несмотря на то что он приватный.

    print("pt._Point__z = ", pt._Point__z)

    // Вывод
    pt._Point__z =  30

Таким образом мы можем получать доступ к приватным атрибутам обьекта.




















