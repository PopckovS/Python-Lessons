## №2 Обьектно ориентированное программирование

### Обьект
Можно оперировать 2 сущьностями, обьектами и классами, мы можем
создать обьект класса, для создания обьекта класса, записываем 
название класса и круглые скобки что и означает созданеи обьекта: 

    class Point():
        def __init__(self, name):
            self.name = name

    obj = Point('Название')

    print(obj)
    print(type(obj))

Сделав вывод значения и типа, увидем метсоположение обьекта в 
памяти и тип обьекта, тоесть  класс от которого он создан.

    Значение: <__main__.func5.<locals>.Point object at 0x7f09ab561e80>
    Тип:      <class '__main__.func5.<locals>.Point'>

Создав обьект мы можем оперировать его статическими и динамическими
атрибутами.

### Класс
Также по мимо создания обьекта, мы можем оперировать самим классом,
для этого берем сам класс, для этого записываем название самого класса:

    class Point():
        def __init__(self, name):
            self.name = name

    print(Point)
    print(type(Point))

Как видимнам не требуется создавать обьект класса, мы можем сразу к 
нему обращаться по его имени, только теперь значением класса будет 
его местоположение а его типом будет спец тип данных `type`

    Значение:  <class '__main__.func5.<locals>.Point'>
    Тип:       <class 'type'>


### Модификаторы доступа public, protected, private
Стандартные модификаторы доступа работают также как и в других 
языках программирования, `public` дает доступ всем, `protected` дает
доступ в классе и его дочерних классах но не из вне, `private` дает
доступ только в самом классе и больше нигде.

В Python эти модификаторы указываются при помощи нижних подчеркиваний:

1) public - любое обычное написание переменной `atribut`
2) protected `_` одно нижнее подчеркивание `_atribut`
3) private - `__` два нижних подчеркивания `__atribut`

### Статические свойства/поля
Статические переменные класса можно указывать в самом классе,
а не в методе инициализаторе `__init__(self)` для вызова этой 
статической переменной класса, требуется указать название самого
класса и обратится к переменной, делается это так:

    class My_class():
        """Это статическая переменная класса"""
        static_var = "Статическая переменная класса"

        def __init__(self, x, y):
            """Это динамические переменные обьекта"""
            self.x = x
            self.y = y

        def show(self):
            print("Динамические:", self.x, self.y)
            print("Статические:", My_class.static_var)

    print("Статические:", My_class.static_var)
    obj = My_class(10, 20)
    obj.show()

    Статические: Статическая переменная класса
    Динамические: 10 20
    Статические: Статическая переменная класса

ак мы можем обращаться к статическим переменным как в нутри 
класса так и снаружи, также все статически переменные поддерживают 
модификаторы доступа.

### Статические методы
Вот тут очень интересно, обычно требуется создать метод и дать 
ему декоратор `@staticmethod` также такие методы не требуют 
получения `self` как первый параметр.

Однако любой метод без первого аргумента `self` будет вести себя 
как статический метод, даже если он не обернут `@staticmethod`

По идеи любой метод обьявленный в классе, ведет себя как статический,
Тоетсь будут работать оба варианта, что через методо без `self` и без
`@staticmethod` что без `self` но с `@staticmethod` к примеру так:

    class Point():
        static_count = 10

        def __init__(self, x, y):
            self.x = x
            self.y = y

        def setCoords(self, x, y):
            self.x = x
            self.y = y

        def getCoords(self):
            print(f"getCoords {self.x}, {self.y}")

        @staticmethod
        def geCountOne():
            print(f"geCountOne = {Point.static_count}")

        def geCountTwo():
            print(f"geCountTwo = {Point.static_count}")

    pt = Point(1, 2)
    
    pt.getCoords()
    pt.setCoords(10, 20)
    pt.getCoords()
    
    Point.geCountOne()
    Point.geCountTwo()

    // Вывод
    getCoords 1, 2
    getCoords 10, 20
    geCountOne = 10
    geCountTwo = 10


### Инкапсуляция 
Основа механизма инкапсуляции это ограничение доступа к методам и 
полям обьекта и класса.

Для соблюдения правил инкапсуляции переменные обьявляются с указанием
доступа, тоесть защищенные или приватные, но в таком случае мы не 
имеем возможности установить их значения.

Для этого используются геттеры и сеттеры, публичные методы для установки
значений переменным:

    class Point():

        def __init__(self):
            print("Класс создан")
        
        def setCoords(self, x, y):
            self.__x = x
            self.__y = y

        def getCoords(self):
            return self.__x, self.__y

    x = Point()
    x.setCoords(10, 20)
    print(x.getCoords())

Таким образом через промежуточные методы мы можем установить данные
даже в закрытые переменные, также в сеттеры можно устанавливать 
проверку на то какие именно данные будут внесены в закрытые переменные.

К примеру такая проверка:

    def setCoords(self, x, y):
        if (isinstance(x, int) or isinstance(x, float)) and \
            (isinstance(y, int) or isinstance(y, float)) :
            self.__x = x
            self.__y = y    else:
            print("Координаты должны быть числами")

При такой проверке мы не сможем вставить в переменную неправильные 
данные, также можно вынести валидацию данных в отдельный метод, и 
проверять их так:

    class Point():

        def __init__(self):
            print("Класс Point создан")

        def __checkValue(x):
            if isinstance(x, int) or isinstance(x, float):
                return True
            return False

        def setCoords(self, x, y):
            if __checkValue(x) and __checkValue(y):
                self.__x = x
                self.__y = y 
            else:
                print("Координаты должны быть числами")

        def getCoords(self):
            return self.__x, self.__y




