Docker Compose
---
---

[Почитать подробнее](https://dker.ru/)

Когда нам требуется развернуть только одно приложение, то достаточно
использовать Dockerfile, но если нам требуется развернуть множество 
контейнеров, для таких манипуляций можно использовать механизм
Docker Compose.

Docker Compose - позволяет решать различные задачи, связанные с 
управлением одновременно несколькими контейнерами, составляющих
в целом один проект.

---

**docker-compose.yml**

`docker-compose.yml` - документ для описания команд `docker compose`,
для запуска множества контейнеров в одном проекте, как и `Docekrfile`
должен располагаться в корне проекта, совместно с `Docekrfile`

Скажем у нас есть проект на Python, создадим для него `Dockerfile`
и опишем для него установку всех зависимостей.

```dockerfile
FROM python:3.8
ENV PYTHONUNBUFFERED 1
RUN mkdir /code
WORKDIR /code
ADD requirements.txt /code/
RUN pip install -r requirements.txt
ADD . /code/
```

В том же каталоге создадим файл `docker-compose.yml` этот файл 
описывает сервисы `services` каждый из таких сервисов, представляет
собой отдельный докер контейнер.

Сервисами могут быть web-серверы, базы данных, сервер nginx для 
запуска фронта отдельно от сервера бэка, чистый бэк в виде API.

Так же в файле описываются образы в котором будут развернуты 
эти самые сервисы, как они будут связаны и какие тома данных
нужно смонтировать в контейнеры, то есть какие директории с 
программным кодом будут скопированы в эти контейнеры, и описывает
какие именно порты будут открыты в основную ОС.

И так наш `docker-compose.yml` будет состоять из 2 сервисов.

```dockerfile
# Указание версии docekr compose
version: '3'

# Сервисы, каждый сервис это отдельный докер контейнер
services:

  # Название сервиса может быть любым, тут мы называем его db
  # в параметре image мы указываем изображение, в котором будет
  # развернут контейнер, тут мы указываем postgres и этот образ 
  # будет скачен с Docker Hub и установлен в контейнер       
  db:
    container_name: db01
    image: postgres
    
  # Контейнер для запуска сервера,     
  web:
  
    # Даем контейнеру специальное имя    
    container_name: web01
  
    # Мы указываем либо образ image который будет закчен с Hub
    # либо указываем свой образ созданный нами, тут точка означает
    # создать из текущей директории, учетом текущего Dockerfile      
    build: .
    
    # command указывает какую bash команду выполнить, тут запуск сервера    
    command: python manage.py runserver 0.0.0.0:8000
    
    # volumes - так называемые тома, путь директорий в которых 
    # будет храниться данные что находятся за пределами контейнеров    
    volumes:
      - .:/code
      
    # Указываем порт который требуется прокинуть между системами
    # Первый 8000 это порт в основной системе, второй 8000 это порт
    # который находится во внутренней системе контейнера         
    ports:
      - "8000:8000"
      
    # указываем зависимости, тоетсь с начала должен быть запущен
    # контейнер db и только после этого контейнер web          
    depends_on:
      - db
```

---

Когда мы создаем образ сервиса, то либо указываем изображение 
`image` либо `build` по сути `build` это конструктор, описывающий
как создать образ для сервиса, вот 2 способа его описания:

```dockerfile
    build: .
```

```dockerfile
    build:
      context: ./
      dockerfile: Dockerfile
```

---

`volumes` - тут можно указать путь к директории, эта директория 
будет местом хранения общих данных, данных что должны быть 
использованы между контейнерами. 

```dockerfile
volumes:
      - .:/code
```

---

Важность `volumes` при использовании между контейнерами
---

У нас есть такой `docker-compose.yml` файл, в котором мы запускаем
3 сервиса:

1) Django в котором реализована API система.

2) Celery который будет принимать у Django задачи для асинхронного
выполнения.

3) Redis как брокер сообщений и бэк результатов.

По скольку Celery должен работать с тем же самым кодом, что 
находится в самом Django, то мы можем указать Celery использовать
тот же контейнер что использует и сам Django.

Помимо того что указание `image` может указывать на скачивание 
изображения с Docker Hub, так же мы можем создавая свое 
собственное изображение указать тут его имя, что бы другие 
сервисы могли от него наследоваться.

В этом примере Django и Celery должны иметь возможность работать
с одним и тем же кодом, для этого у контейнера Django мы указываем
его собственное изображение `image: 'web_app'` и далее сервис
Celery наследуется от него, указывая то же самое изображение, таким
образом контейнер с Celery будет как бы наследоваться от того же 
самого изображения, и использовать тот же самый код.

Другой важный момент ! Если в самом Celery мы не просто выполняем 
некоторый программный код, но и сохранять, изменять или как либо 
работать с общими файлами/директориями, то обязательно требуется
указать общие директории, в которых и будут находиться 
файлы/директории для общей работы, указать эти общие директории
мы можем при помощи директивы `volumes` которая должна быть указана
в обоих сервисах.

```dockerfile
volumes:
      - .:/usr/src/app
```

Таким образом наш финальный `docker-compose.yml` будет выглядеть 
следующим образом:

```dockerfile
version: '3'

services:

  # Сервер для Django
  webapp:
    container_name: web01
    image: 'web_app'
    build:
      context: ./
      dockerfile: Dockerfile
    ports:
      - "8001:8000"
    volumes:
      - .:/usr/src/app
    command: python3 manage.py runserver 0.0.0.0:8000

  # Celery для Django
  celery:
    container_name: django_celery
    image: 'web_app'
    depends_on:
      - webapp
    command: celery -A config worker -l info
    volumes:
      - .:/usr/src/app

  # Redis как брокер сообщений между Django и Celery
  redis:
    image: redis:alpine
```
