Конфликты
---
Конфликты возникают, когда при слиянии разных версий програмного кода 
один и тот же участок кода имеет 2 разных версии, и `git` просто не 
знает какой именно участок кода оставить при слиянии.

При возникновении конфликтов, в файле с конфликтом, выводится специальное
описание, которое показывает 2 версии програмного кода, из 2 разных версий,
таким образом мы можем увидеть подробное описание обеих версий, и решить 
какую из них оставить.

    <<<<<<< HEAD
    this is some content to mess with
    content to append
    =======
    totally different content to merge later
    >>>>>>> new_branch_to_merge_later

`=======` - это центр конфликта, все содержимое между этим центром и 
строкой `<<<<<<< HEAD` является содержимым версии кода из гдавной ветки,
в которую мы вливаем изменения, а содержимое между центром и строкой
`>>>>>>> new_branch_to_merge_later` это версия вливаемой ветки.

Выбрав и оставив одну из версий программного кода,ы должны пометить его
как файл с решенным конфликтом, для этого просто достаточно пометить его
через `git add file.py`

---

В `git` существует 2 метода внедрения изменений из одной ветки в другую,
это `git merge` и `git rebase` слияние и перебазирование.

---
git merge
---
Слияние одной ветки с другой


---
git rebase
---
И так, есть ветка `dev` и ветка `feature`,
если ветка `feature` она создана от ветки `dev` и на протяжении всей 
работы с веткой `feature` в ветки `dev` не было никаких изменений, то в такои
случае, мы можем без препятственно влить влить `feature` в ветку `dev` как
с помощью метода `merge` так и `rebase` и никаких проблем и кнфликтов не 
будет.

Но в случае если в процессе работы с `feature` в ветку `dev` тоже были
внесены изменения, то в таком случае, при слиянии могут возникнуть конфликты,
но даже при решении этих конфликтов, при слиянии ветки `dev` с веткой 
`feature` по истории коммитов будет видно что было ветвление.

И наконец метод `rebase`, когда мы находимся в ветке `feature` и в тот же 
момент в ветке `dev` происходили коммиты, когда находясь в ветке `feature`
мы можем сделать `git rebase dev` после этого, все коммиты что были сделаны
в ветке `dev` с момента когда мы создали ветку `feature`, все эти коммиты 
будут перемещены из ветки `dev` в ветку `feature`, и будут вставлены в 
самое начало ветки `feature`, и уже после них, на эти коммиты вставленные 
из ветки `dev` поверх, будут вставлены те коммиты которые были в ветке
`feature` до того как мы ввели команду `git rebase dev`, то есть будут
создано впечатление как будто мы ответвились от ветки `dev` только что,
и никто никаких коммитов в ветке `dev` попросту не успел сделать с момента
нашего ветвления.

А после этого мы можем с помощью `git merge` просто влить ветку `feature`
в ветку `dev` и никаких конфликто не будет, однако конфликты могут
возникнуть на момент перебазирования `git rebase dev` в нутри ветки
`feature`, конфликты в любом случае предется решать, но их решение будет 
происходить в нутри ветки `feature` до слияния с веткой `dev`.

Если в процессе `git rebase dev` возникают конфликты, то их преедется решать,
в момент возникновения конфликта мы можем отменить перебазирование с 
помощью команды:

    git rebase --abort

Или, решив конфликт, мы можем продолжить перебазирование с помощью команды:

    git rebase --continue 

И завершить перебазирование.