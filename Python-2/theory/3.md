### Python Уроки - 3


### Теория

### sys.executable
Параметр `sys.executable` выводит полный путь к интерпретатору Python

    // Через обынчный локальный интерпретатор
    python3 2.py
    /var/www/Python-programm/venv/bin/python3

    // Через сшибанг в начале файла
    ./2.py
    /usr/bin/python3

### sys.exit()
Используется для выхода из программы, имеет необезательный атрибут 
в виде числа, где 0 это успешный выход, при его использвании вызывается
исключений типа `SystemExit` которое можно перехватывать

### Функциональное программирование
В основном питоне это не Ффнкциональный язык программирования, 
в питоне есть lambda функции но используются они не часто, и 
если используются то для решения простейших задач.

Обычные функции именованы, lambda это тоже функция но не 
именованная, так что при получении ошибки мы не увидим ее имени.

Основные инструменты функционального в питоне:

1) lambda
2) map
3) filter
4) zip 

### LEGB
L - local E - enclosing G - global B - built in

4 области видимости в которых ведется поиск переменной, это в локальной 
области, далее в области видимости функции более высокого уровня если 
она есть, далее в глобальной области, и в конеце во встроеной области
`builtin`

Эти встроеные имена находятся в `builtin` области видимости которая 
представляет из себя файл `builtins.py` это файл где они обьявленя 
и импортированы по дефолту в программы.  

### Модуль dis
Этот модуль позволяет декомпилировать байт-код Python и изучить его, 
это позволяет проводить процесс реверс-инжиниринг.

### Расширенная распаковка
Распаковка возможна не только для структур данных но и для строк 
и для обьекта `range()`

    x, y, z = 'abs'
    print(x, y, z)

    a, *b = 10, (20, 30), (40, 50)
    print(a, b)

    x, y = b
    print(x, y)

    first, *second, last = range(1, 5)
    print(f'first = {first} second = {second} last = {last}')

Также интересен то как происходит присваивание, при этом процессе
значения перезаписываются, к пимеру так:

    x, (x, y) = 1, (2, 3)

    print(x)
    print(y)

    // Вывод
    2
    3

С начала x получает значение 1, а после перезаписываетя на 2, а 
y получает значение 3

### Инициализация аргументов по умолчанию
У нас есть возможность задавать аргументам значение по умолчанию,
но эта инициализация происходит только один раз в момент компиляции
в байт код, и далее они обнулятся не будут, каждый новый вызов 
функции будет сохранять эти аргументы по умолчанию, они будут 
сохранены в атрибуте `function.__defaults__` этот атрибут содержит
кортеж с аргументами по умолчанию.

Если аргументами по умолчанию являются неизменяемые типы то все впорядке,
от вызова функции к вызову функции они нятся не будут, но в случае если
это изменяемвый тип то тут может возникнуть проблема, потому что тут
от вызова к вызову эти аргументы по умолчанию будут менятся.

Рассмотрим такой пример кода, тут по умолчанию есть множество, от вызова 
к вызову это множество меняется, потому что множество изменяемый тип,
так что тут надо быть акуратным.

    def unique(iterable, seen=set()):
        acc = []
        for item in iterable:
            if item not in seen:
                seen.add(item)
                acc.append(item)
        return acc

    xs = [1, 1, 2, 3]
    print(unique(xs))

    print('Аргументы по умолчанию', unique.__defaults__)

    xs = [1, 1, 2, 3, 4, 5, 6, 7]
    print(unique(xs))

    print('Аргументы по умолчанию', unique.__defaults__)

    // Вывод
    [1, 2, 3]
    Аргументы по умолчанию ({1, 2, 3},)
    [4, 5, 6, 7]
    Аргументы по умолчанию ({1, 2, 3, 4, 5, 6, 7},)

**Вывод: стоит избегать в качестве аргументов по умолчанию 
изменяемые типы данных.**

**Как тогда поступить ?**
Поступать стоит так, в качестве аргумента по умолчанию все таки 
использовать неизменяемый тип данных, а после в самой функции 
ее инициализировать, к примеру можно сделать так:

       def unique(iterable, seen=None):
            acc = []
            seen = set(seen or [])
            for item in iterable:
                if item not in seen:
                    seen.add(item)
                    acc.append(item)
            return acc

Эта строчка `seen = set(seen or [])` задает множество, либо то 
что было передано, либо полностью пустое, тоесть None интерпретируется 
как false мы получаем пустое множество, а если множество было передано 
то оно и вставляется.

### Хорошая практика
По скольку нам требуется чтобы было что сортировать, то нам
необходимо чтобы в функцию приходил хотябы один аргумент, для
этого реализуем сразу 2 аргумента в функцию def min(first, *args)
аргумент first обезательный аргумент так что мы точно получим 
хотябы 1 аргумент для сортировки, а потом просто в условии цикла
обьеденяем их в кортеж по которому будем идти (first, ) + args

Таким образом мы обязуем передавать хотябы 1 аргумент, и в тоже 
время работаем с ними как с единым кортежем. 

    import math

    def find_min(first, *args, min_inf=-math.inf, max_inf=math.inf):
        result = max_inf
        for element in (first, ) + args:
            if element < result and min_inf < element < max_inf:
                result = element
        return max(result, min_inf)

    print(find_min(88, 12, 13, -5, min_inf=0, max_inf=255))
    print(find_min(12, 13, -5))

    // Вывод
    12
    -5






























