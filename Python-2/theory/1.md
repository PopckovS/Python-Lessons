### Python Уроки - 1

### Теория
Python - прообразом для создания являются 2 языка, это `ABC` и `Modula-3`

`ABC` - язык без скобок а с отступами, откуда питон

`Modula-3` - был первям языком в которо была конструкция `try except` так же
он был модульным языком, откуда и пошла модульность самого питона.

При интерпритировании создается Байт код, который никак не привязан а 
архитектуре, иможет выполняться в разных виртуальных машинах, по дефолту 
использется  интерпритатор `Cpython`, но есть и другие вирт машины для 
его исполнения: PyPy(тотже Cpython только с JIT мпиляцией), Jpython(для Java),

2 и 3 версии питона, главная причина этио переход строк с байтового на 
Unicod и многие другие изменения.

Модуль - это специальный класс который организует свое содержимое в некое 
подобие обьекат, Любой файл с `.py` задает модуль.:

    <module 'os' from '/usr/lib/python3.6/os.py'>
    <class 'module'>

У каждого модуля есть атрибут `__name__` который содержит название модуля 
соответствующее названию файла, и не может называться с цифр, ибо является 
идентификатором, и импортировать его неполучиться.

bool - класс что наследуется от типа `int`


### 1
Все в питоне есть обьект какого либо класса:

    a = 54
    print(type(a))
    print(type(type(a)))

    <class 'int'>
    <class 'type'>

### 2
None - это класс у которого реализован пааттерн синглтона, так что етсь 
только один None  все программы, и его проверка на самого себя вернет `True` 
 
    print('Проверка по значнеию None == None', None == None)
    print('Проверка по ссылке None == None', None is None)

    True
    True

### is
`is` - Это сец оператор для проверки обьектов по ссылке а не по значнеию, 
в то время как `==` авнивает обьекты именно по значению.

### int 
int - тип с произволной точностью, к что можно производит вычисления с 
огромными числами:

    print(23423423324235325345353453453453453434534553534534534**23)

    3176570138216911739091212499933062068970237146187861775218324230
    0864627905744930245741026835993629437346965792527513768359030778
    8573391214780477871811737552927333509853638485224391523504587460
    5776590246602826957114902353211577889058134114170456304429767979
    799220653



### __code__
Замена байт кода одной функци, байт кодом другой функции, у обьектов в 
питоне есть атрибут `__code__` заменяя код одного обьекта другим мы 
полностью заменяем код обьекта.

    def func1(a, b):
        print(a * b)

    def testing():
        pass

    print(func1)
    print(func1.__code__)

    testing.__code__ = func1.__code__
    testing(2, 5)

    <function func4.<locals>.func1 at 0x7f70513739d8>
    <code object func1 at 0x7f70513d5e40, file "./1.py", line 71>
    10

### os.path()
`os.path.basename` - вернет названия файла в этом пути, последнний файл:

    print(os.path.basename(r'C:\Python27\Tools\pynche\ChipViewer.py'))
    ChipViewer.py

`os.path.dirname` - вернет все до последнего файла:

    print( os.path.dirname(r'C:\Python27\Tools\pynche\ChipViewer.py') )
    C:\\Python27\\Tools\\pynche

`os.path.exists` - ворит о существовании файла или нет.

`os.path.isdir / os.path.isfile` - аналогичная проверка на существование.

`os.path.join` - совмещает пути при помощи разделителя в текущей операционной 
системе:

    print(os.path.join(r'C:\Python27\Tools\pynche', 'ChipViewer.py'))
    C:\\Python27\\Tools\\pynche\\ChipViewer.py

### Метод os.walk(dir)
Этот метод получает аргумент строку пути, сканирует все содержимое, и 
возвращает обьект генератор со всем содержимым, содержимое генератора
имеет структуру:

    ('Корень директории', [Список со всеми под директориями], [список файлов])

Пройдемся по генератору циклом for: 

    test_dir = 'test-dir'
    gener = os.walk(test_dir)

    for root, dirs, files in gener:
        print(root, dirs, files)

    // Вывод
    test-dir ['test-dir-2'] ['test.txt']
    test-dir/test-dir-2 [] ['test-2.txt']

Или методом `next()`:

    test_dir = 'test-dir'
    gener = os.walk(test_dir)

    print(next(gener))
    print(next(gener))

    ('test-dir', ['test-dir-2'], ['test.txt'])
    ('test-dir/test-dir-2', [], ['test-2.txt'])

Если использовать символ `/` то получим списки всех путей на пк










