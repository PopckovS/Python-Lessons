### Python Уроки - 2

### Теория 
**Списки**

Списки - в нутри являются массивами, просто называются списками, но это
массив а не списки как в других языках, скорость доступа к элементам по
индексам происходит за константу и получение длинны списка за константу,
также списки как и строки можно канкатенировать при помощи символа плюса.
Списки стараются использовать для хранения значений одинаковых типов.

**Словарь**

Словарь - Это хеш таблица, отображение с ключами и значениями, это 
изменяемый тип, при указании пустых скобок при обьявлении переменной
`a = {}` создаст не множество а именно словарь. 

По дефолту проверяя есть ли чтото в словаре при помощи оператора `in` 
проверка будет идти в его ключах а не значениях:

    my_dict = {'a': 10, "b": 20, "c": 30}
    print('10 в значениях словаря: ', 10 in my_dict.values())
    print('a в значениях словаря: ', 'a' in my_dict)

    10 в значениях словаря:  True
    a в значениях словаря:  True

Тоесть для проверки следующие 2 варианта эквивалентны др др:

    'a' in my_dict 
    'a' in my_dict.keys()

**Базовые(Встроеные типы) типы**
1) None
2) boole
3) int, float, complex
4) bytes, str
5) list, set, dict
6) tuple

**Тернарный оператор**
Оператор для работы с 3 перемеными, по сути это просто `if` но в 
одну строчку:

    var = 500
    result = True if var >= 100 else False
    print(f'var = {var} result = {result}')

    var = 500 result = True

**Цикл for**
В других языках это соответствует циклу `foreach` тоесть тут for 
именно итерируется по некой последовательности а не по просто проверяет 
условие как `for` в других языках. По этому используется генератор 
последовательности `range()` чобы сгенерить что-то по чему можно 
итерироваться.

У циклов есть блок `else` который исполняется всегда если не было
использовано оператора `break`. Такаяже логика используется и в `while`

**Метод range(start, end, step)**
Метод `range()` создает не список а особый обьект, по которому можно 
итерироваться при помощи цикла `for` но списком не является, и
для прверващения в список требуется указать это явно:

    some = range(1, 11)
    print(some)
    print(type(some))

    my_list = list(some)
    print(my_list)
    print(type(my_list))

    // Вывод
    range(1, 11)
    <class 'range'>
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    <class 'list'>

**Бесконечное число**
Есть 2 способа представить бесконечное число, либо с помощью `math.inf`
который возвращает бесконечное число, либо с помощью метода `float()`

    import math
    max_infinity = math.inf
    min_infinity = -math.inf

    max_infinity = float("inf")
    min_infinity = float("-inf")

**Упаковка и распаковка**
Когда мы передаем в функцию ряд неименованных аргументов, эти аргументы 
приходят в функцию в качестве обьедененного кортежа, это называется
упаковкой и указываетяся она при помощи символа звездочки `*args` 

Но есть и обратный процесс, распаковка, это процесс когда мы из структуры
изымвем все ее елементы, то етсь тут эти переменные уже не обьеденены
некой структурой, прсото ряд переменных, вот пример:

    def function_1(*args):
        print('Пример с распаковкой:')
        print(type(args))
        print(*args)

    def function_2(*args):
        print('\nПример без распаковки:')
        print(type(args))
        print(args)

    function_1(1,2,3,4)
    function_2(1,2,3,4)

    // Вывод
    Пример с распаковкой:
    <class 'tuple'>
    1 2 3 4
    
    Пример без распаковки:
    <class 'tuple'>
    (1, 2, 3, 4)

### Unicod строки и Байтовые строки в Python
В Питоне есть 2 типа строк, Unicod строки и Байт строки, по дефолту 
все строки имеют кодировку Unicod. Для обьявления Байт строк перед строкой 
записываем спец символ `b` и она учавствует в выводе на экран, также 
они имеют разный тип обьектов, `str` и `bytes` вот пример:

    str_1 = 'привет мир'
    str_2 = b'hello world'

    print('Unicod строка: ', str_1)
    print('Байтов строка: ', str_2)

    print(f'Тип Unicod роки: {type(str_1)}\nТип Байт строк: {type(str_2)}')

    // Вывод
    Unicod строка:  привет мир
    Байтов строка:  b'hello world'
    Тип Unicod роки: <class 'str'>
    Тип Байт строк: <class 'bytes'>

Существует кодировка ASCII - которая включает в себя небольшой набор чисел и
латиницы, именно по этой кодировке работал питон2

Есть таблица Unicod и ее часть UTF-8 всключает в себя всю ASCII и расширяет 
ее, теперь в Питон3 по дефолту используется именно эта кодировка, и это
работает не только на содержимое строк, но и на написание самой программы,
теперь в качестве символов имен можно использовать все то что входит в 
Unicod, так что теперь можно давать русские и не только, названия именам:

    переменна = "Да это работает"
    print(переменна)

    class МойКласс:
        def __init__(self, x, y):
            self.x = x
            self.y = y

    обьект_моего_классса = МойКласс(10, 20)
    print(обьект_моего_классса.__dict__)

    // Вывод
    Да это работает
    {'x': 10, 'y': 20}

### chr ord
В системе кодировок есть привязка к целым числам, для получения значения 
символа от числа или числа от символа, используется 2 метода, все это 
делается из таблицы имен Unicod.

chr - по числу возвращает его символ.

ord - по символу возвращает его число.

    print(chr(65))
    print(ord('A'))

    A
    65








