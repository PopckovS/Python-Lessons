Магические методы, dunder-методы в Python
---

Существует порядка 120 магических методов, но не все они используются,
расмотрим самые частые из них.

магические методы еще называют dunder-методами.

1) `__new__(cls, arg)` - Истинный конструктор класса, метод `__init__`
называют конструктором по привычке.
   
Он является методом класса, тоесть должен быть статическим и использовать
для этого декоратор `@classmethod` но этот метод обрабатывается особенным
образом, так что декоратор для статичности он не использует.

Этот должен возвращать экземпляр класса, тоесть должен создавать обьект 
и возвращать его, именно этот обьект и передается в метод `__init__(self)`
как первый аргумент `self`

Поскольку метод `__init__()` ничего не может возвращать получается что 
обьект создается в методе `__new__` а метод `__init__` прсото инициализирует
переменный обьекта.

---

Основные магические методы
---

1) `__init__(self)` - Метод конструктор(как его обычно называют), 
   используется для инициализации динамических атрибутов класса, 
   запускается автоматически при создании обьекта.
   
   Этому методу запрещено возвращать чтолибо кроме `None` что является
   стандартным поведением методов и функций, любая функция что то 
   возвращает, и если это не переопределено то возвращает `None`

2) `__str(self)__` - Должен возвращать при помощи ключевого слова
`return` строку описывающую класс, этот метод вызывается автоматически 
   когда обьект вызывается при помощи функции `print()`
   
2) `__repr(self)__` - Должен возвращать строковое представление класса,
при помощи оператора `return`. Используется автоматически когда на 
   класс используется функция `repr()` помним чтосама по себе функция 
   `repr()` не выводит строку а только ее возвращает, так что для этого 
   следует использовать комбинацию `print(repr(obj))`

3) `__len__(self)` - Используется автоматически при использовании метода
`len()` на обьект, этот метод обязан возвращать целочисленное значение
типа `int` при помощи `return`

Пример использования магич методов `__init__`, `__str__`, `__repr__`, 
`__len__()`:

```python
        class MyClass():

            def __init__(self, name, my_list):
                self.name = name
                self.my_list = my_list

            def __str__(self):
                return "Метод __str__"

            def __repr__(self):
                return "Метод __repr__"
   
            def __len__(self):
                return len(self.my_list)


        x = MyClass('Антонио', [1,2,3,4])
        print(x)
        print(repr(x))
        print(len(x))

        # Вывод
        # Метод __str__
        # Метод __repr__
        # 4
```

4) `__del__(self)` - Метод не должен ничего возвращать, отрабатывает при 
   уничтожении последней ссылки на обьект.
   
```python
    def __del__(self):
        """
        __del__ деструктор класса, вызывается при уничтожении
        последней ссылки на обьект этого класса.
        """
        print("Отработал метод __del__ Обьект класса MyClass уничтожен")
```

5) `__abs__(self)` отрабатывает при использовании на обьект функции abs()
для получения значения по модулю, может возвращать как число так и список.
   
Возвращать что либо не обезательно.

6) `__hash(self)__` отрабатывает при использовании функции хеширования на 
   обьект. Если использовать функцию hash() на обычное целое число ответом
   будет саможе это число, но другие данные float или str ... будут 
   преобразованы в целое число.

---   

Поведения обьектов при сравнении операторов
---

Эти методы определяют поведения обьектов когда на них используеются 
операторы сравнения.

Для сравнения эти методы принимают 2 параметра, `self` что представляет 
сам обьект, и `other` что представляет другой обьект.

1) `__eq__(self, other)` - поведения при `==`

2) `__cmp__(self, other)` - этот метод определят поведение для всех 
операторов, этим обьектом можно определить поведение всех обьектов
и всех их операторов.

3) `__ne__(self, other)` - Определяет поведение оператора 
   неравенства `!=`

4) `__lt__(self, other)` - Определяет поведение оператора меньше `<`

5) `__gt__(self, other)` - Определяет поведение оператора больше `>`

6) `__le__(self, other)` - Определяет поведение оператора меньше
    или равно `<=`

7) `__ge__(self, other)` - Определяет поведение оператора больше
    или равно `>=`

Примеры поведения, на этом примере можно увидеть как работает метод для 
переопределния операторов сравнения, суть такова, метод принимает 
2 параметра `self` и `other` где есть собственный и дополнительный 
обьект, а далее мы сами можем переопределить поведение, возвращаем либо 
True либо False это можно увидеть на след примере:

```python
      class Test():

       def __init__(self, name):
           self.name = name
   
       def __eq__(self, other):
           print(f"self = {len(self.name)}", self)
           print("other = ", other)
           if len(self.name) == other:
               return True
           return False
   
   
      x = Test('Names')
      print(x==5)

      # Вывод
      # self = 5 <__main__.Test object at 0x7f5ad9ddc208>
      # other =  5
      # True
```

---

Маг.Методы контроля доступа к атрибутам
---

1) `__getattr__(self, name)` Вызывается при попытке вызова метода 
   которого не существует.

2) `__setattr__(self, name, value)` Позволяет установить новое значение
   для атрибута, существует он или нет.

3) `__delattr__(self, name)` 

4) `__getattribute__(self, name)` 

---

Спец метод `__getitem__(self, key)`
---
Метод отрабатывает когда мы обращаемся к обьекту как к элементу списка,
по индекусу, примеру так:

```python
    from string import ascii_letters

    class MyContainer(object):

        def __getitem__(self, key):
            print('key = ', key)
            return ascii_letters[key]

    my_container = MyContainer()
    
    print(my_container[0])  # выведет a
    print(my_container[16])  # выведет q
    print(my_container[:])  # выведет все элементы

    # Вывод
    # key =  0
    # a
    # 
    # key =  16
    # q
    # 
    # key =  slice(None, None, None)
    # abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
```

Переменная из `ascii_letters` содержит в себе все буквы алфавита.

---

Атрибут `__code__`
---
Замена байт кода одной функци, байт кодом другой функции, у обьектов в 
питоне есть атрибут `__code__` заменяя код одного обьекта другим мы 
полностью заменяем код обьекта.

```python
    def func1(a, b):
        print(a * b)

    def testing():
        pass

    print(func1)
    print(func1.__code__)

    testing.__code__ = func1.__code__
    testing(2, 5)

    # Вывод
    # <function func4.<locals>.func1 at 0x7f70513739d8>
    # <code object func1 at 0x7f70513d5e40, file "./1.py", line 71>
    # 10
```

---

Магический метод __hash__(self)
---

При использовании функции hash() на данные мы по сути вызываем метод
__hash__() этого обьекта, ибо все данные в питоне являются обьектами.

У обьектов можно определить метод `__hash()__` которая будет отрабатывать 
при использовании функции hash() на этот обьект, так образом можно самим
определять свои собственные функции для хеширования.













