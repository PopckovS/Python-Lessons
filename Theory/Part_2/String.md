 Строки 
---
Строки это объекты своих классов, у строк есть такое свойство как
`immutabillity` которое отвечает за изменяемость объекта, и строки
являются неизменяемым объектом.

Но можно создать новую строку путем конкатенации с помощью `+`

---

Оператор `%s`
---
При помощи специального оператора `%s` можно форматировать строки, 
вставлять в них данные, есть 2 формы записи этого метода:

```python
    hello = 'Hello World'

    print('Тут будет вставлена переменная %s' %(hello) )
    print('Тут будет вставлена переменная %s' %hello )
    
    var_1 = 'var_1'
    var_2 = 'var_2'
    var_3 = 'var_3'
    
    print('%s ; %s ; %s' %(var_1, var_2, var_3) )
    
    # Вывод
    # Тут будет вставлена переменная Hello World
    # Тут будет вставлена переменная Hello World
    # var_1 ; var_2 ; var_3
```
    
То есть видим что данный оператор помогает нам форматировать строку, 
также он позволяет использовать параметры, которые изменяют формат 
данных. 

Параметр `%1.2f` отвечает за вывод типа `float`. Цифра после точки 
указывает сколько будет символов после запятой. Первая цифра указывает
минимальное количество символов которое будет перед запятой.

```python
    var = 145.137
    print('Число = %1.10f' %(var) )
    
    # Вывод
    # Число = '145.137'
```
    
Другой параметр это `%r` если первый `%s` использует функцию str() для 
конвертации, то второй использует функцию `repr()`

```python
    var = '145.137'
    print('Число = %1.10f' %(float(var)))

    # Вывод
    # Число = '145.137'
```
    
Можно форматировать множество объектов этими операторами, обратим 
внимание, что элементы передаваемые в строку являются кортежем.

```python
    print('0 = %s, 1 = %s, 2 = %s ' %('hi', 'two', 3))

    # Вывод
    # 0 = hi, 1 = two, 2 = 3  
```

---

Методы строк
---

1) `isupper()` - проверка является ли рока в верх регистре
2) `islower()` - проверка является ли строка в нижнем регистре 
3) `upper()` - возведение в верх регистр
4) `lower()` - переводит в низ регистр
5) `split('char')` - принимает символ по которому разделяет список на части
6) `format()` - вставляет в строку указанные данные
7) `strip()` - Удаляет пробелы с лева и справа в строке.
8) `lstrip()` - Удаляет пробелы с лева.
9) `rstrip()` - Удаляет пробелы с права.

```python
    string = "   Hello World   "

    string.strip()  
    string.lstrip() 
    string.rstrip() 

    # Вывод
    # "Hello World"
    # "Hello World   "
    # "   Hello World"
```
    
`split(str value)` - Метод разбивает строку по указанной подстроке.
Это очень интересный метод, с не явным поведением, если есть строка в 
которой слова разделены пробелами, применив к этой строке метод 
`split()` и не передав никаких аргументов, мы получим слова строки 
представленных как список, без каких либо пробелов, только элементы
предложения по существу, выглядит это след образом:

```python
    string = " Первый Второй  Третий   Четвертый  "
    print(string.split())

    # Вывод
    # Список из слов и только, ничего лишнего
    # ['Первый', 'Второй', 'Третий', 'Четвертый']
```
    
`string.split()` - этот способ удобен когда требуется получить список 
строк. 

Другой способ использовать эту функцию для, разделение строки на список
из слов, это разбить строку по пробелу, `string.split(" ")` в таком 
случае в отдельные элементы будут выделены не только сами слова, но и 
каждый пробел в отдельности.

```python
    string = " Первый Второй  Третий   Четвертый  "
    print(string.split(" "))

    # Вывод
    # Список где каждый пробел превращается в собственный элемент
    # ['', 'Первый', 'Второй', '', 'Третий', '', '', 'Четвертый', '', '']
```

Этот способ может пригодиться когда нам необходимо знать количество 
пробелов как по бокам строки, так и между строк.

---

Независимые функции для работы со строками
---
1) `str()` - превращает в строку переданную переменную
2) `repr()` - создает строковое представление переменной, то есть 
выводит не только значение, но и тип ее:
```python
    var = 123
    print(repr(str(var)))
    print(repr(var))

    # Вывод
    # '123'
    # 123
```

В классах есть специальный маг.метод `__repr__(self)` который
отрабатывает при использовании метода `repr()` на объект класса,
выглядит это так:
```python
    class Pointer:
        def __init__(self):
            pass
    
    class Pointer2:
        def __init__(self):
            ...
        def __repr__(self):
            return 'Hello world !'
    
    po = Pointer()
    po2 = Pointer2()
    
    print(repr(Pointer))
    print(repr(po))
    
    print(repr(Pointer2))
    print(repr(po2))

    # Вывод
    # <class '__main__.Pointer'>
    # <__main__.Pointer object at 0x7fa9ef061e80>
    # <class '__main__.Pointer2'>
    # Hello world !
```

---

Поиск подстроки в строке с нахождением индекса подстроки
---
Метод строки `.find()` позволяет найти индекс первого вхождения
подстроки в строке или возвращает -1.

`string.find(substring, start, end)`

`substring` - где искать

`start` - индекс с которого начинать искать подстроку, по умолчанию
это `0`

`end` - индекс на котором перестать искать, по умолчанию это вся
строка

```python
    string = "Добро пожаловать!"
    print(string.find("о"))
   
    # Вывод
    # 1

    string = "Дбро пожаловать!"
    print(string.find("о"))

    # Вывод
    # 3
```

---

Поиск подстроки в строке без поиска индекса.
--- 
Если нам не интересен поиск индекса подстроки в строке, а интересует 
лишь, находится ли подстрока или нет, то есть `True` или `False`,
то можно сделать это при помощи оператора `in` как и для поиска
элемента в структурах данных.

```python
    string = 'Hi there'

    if 'Hi' in string:
        print('Да эта строка присутствует')
    else:
        print('Подстроки не найдено')

    # Вывод
    # Да эта строка присутствует  
```

Этот способ не позволяет найти индекс вхождения, но лишь дает
заключение есть она там или нет.

---

Еще методы строк
---

**Методы работы с регистром:**

`title()` - Каждый первый символ каждого слова переводит в верхний
регистр

`capitalize()` - Первый символ строки в верх регистр

`swapcase()` - Меняет регистр символов местами

---

**Методы выравнивания:**

`rjust(20, '-')` - Выравнивает по правому краю, добавляет до 20
символов, и эти пробелы заполняет указанным символом. 

`ljust(20, '-')` - Выравнивает по левому краю.

`center(20, '-')` - Выравнивает по центру.

---

**Разное**

`split()` - разбивает строчку на элементы и делает из них список, 
если ничего не передавать то разобьет по пробелу.

`",".join(list)` - соединяет все элементы списка в строчку, в которой 
каждый элемент списка склеен при помощи указанного разделителя.

```python
    my_list = ['a','b','c','d','e']
    print(','.join(my_list))

    # Вывод
    # a,b,c,d,e
```

`replace(search, pattern)` - Ищет в строчке `search` и заменяет на
`pattern`.  

`startswith(str)` - Проверяет, является ли указанная строка начальной 
подстрокой строки.

`endswith(str)` - Тоже проверка, но на окончание строки. 

Также на строки работает сравнение `in` и `not in` следующего типа:

```python
    str_1 = 'привет мир!'
    print(str_1, ' = ', 'привет' in str_1)

    str_2 = 'привет мир!'
    print(str_2, ' = ', 'привsdет' not in str_2)

    str_3 = 'привет мир!'
    print(str_3, ' = ', str_3.startswith('при'))

    str_4 = 'привет мир!'
    print(str_4, ' = ', str_4.endswith('мир!'))

    # Вывод
    # привет мир!  =  True
    # привет мир!  =  True
    # привет мир!  =  True
    # привет мир!  =  True
```
---

Интернирование строк
---
Как помним для каждого объекта хранятся не только его данные, но и счет 
количества ссылок на этот объект, питон сам ведет подсчет ссылок на 
один и тот же объект, если есть 2 строки то питон имеет только один
объект и 2 ссылки на него.

Этот механизм хорошо работает с числами:

```python
    print('\nid(2*3*3) == id(2*3*3) : ', id(2*3*3) == id(2*3*3))
    print('2*3*3 is 2*3*3 : ', 2*3*3 is 2*3*3)

    # Вывод
    # id(2*3*3) == id(2*3*3) :  True
    # 2*3*3 is 2*3*3 :  True
```

Что с обычными числами `555` , что с вычисляемыми значениями `2*3*3`
однако этот механизм работает иначе по отношению со строчками, две 
обычных строчки будут только в одном экземпляре и работать для них 
будет, как обычно, но для вычисляемых строчек этот механизм не 
работает:

```python
    a1 = 'a'*40
    b1 = 'a'*40
    print('\nid(a1) == id(b1) : ', id(a1) == id(b1))
    print('a1 is b1 : ', a1 is b1)

    # Вывод
    # id(a1) == id(b1) :  False
    # a1 is b1 :  False
```

Механизм вычисления для строчек не работает, это будет 2 разных
переменных.

---

Как быстрее вычислять строчки: + против `.format`
---

Надо использовать метод `.format()` вместо конкатенации при помощи 
символа плюса `+` это требует гораздо меньше затрат, при конкатенации
ключом, с начала происходит создание временной строчки, потом новая
конкатенация и создание новой временной строчки и так далее... это 
очень медленно.

Метод format с начала определяет длину строки и подставляет туда все
символы, по итогу получается быстрее.

---

У строк есть метод `isnumeric` `isalpha` `isalnum`
---

`isnumeric` - Метод возвращает `True` если в строке есть только числа.

`isalpha` - Возвращает `True` если в строке только буквы

`isalnum` - Возвращает `True` если в строке только числа + буквы

---

`isalnum()` - Метод принадлежит строчкам, проверяет, являются ли все 
символы строки, буквами и числами если есть другие символы 
то возвращает False.

```python
    var_1 = '123'
    var_2 = 'sdf'
    var_3 = 'asdf4r34'
    
    print(var_1.isnumeric())
    print(var_2.isalpha())
    print(var_3.isalnum())
    
    # Вывод
    # True
    # True
    # True
```