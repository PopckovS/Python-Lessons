Словари
---

Словарь - Это хеш таблица, отображение с ключами и значениями, это 
изменяемый тип, при указании пустых скобок при объявлении явлении
переменной `a = {}` создаст не множество, а именно словарь, дело в
то что множества тоже имеют форму записи с фигурными скобками,
но при создании пустые фигурные скобки, создадут именно словарь,
а не множество. 

По дефолту проверяется есть ли что то в словаре при помощи оператора
`in` проверка будет идти в его ключах, а не значениях, то есть 
следующие 2 примера эквиваленты:

```python
   my_dict = {'a': 10, "b": 20, "c": 30}
   
   print('a в значениях словаря: ', 'a' in my_dict)
   print('a в значениях словаря: ', 'a' in my_dict.keys())
    
    # Вывод
    # a в значениях словаря:  True
    # a в значениях словаря:  True
```

Если хотим проверить значение, именно значение в элементах словаря,
то можно воспользоваться методом словарей `values()`

```python
   my_dict = {'a': 10, "b": 20, "c": 30}
   
   print('10 в значениях словаря: ', 10 in my_dict.values())
   
   # 10 в значениях словаря:  True
```

А что выведут сами методы `values()` и `keys()`:

```python
   my_dict = {'a': 10, "b": 20, "c": 30}
   
   print('values() : ', my_dict.values())
   print('keys() : ', my_dict.keys())
   
   # values() :  dict_values([10, 20, 30])
   # keys() :  dict_keys(['a', 'b', 'c'])
```

Как можно увидеть они выведут специальные объекты, что не принадлежат 
к стандартным структурам данных, так что, если мы хотим сделать из них 
список или кортеж, то требуется специально указать эти преобразования 
типов:

```python
my_dict = {'a': 10, "b": 20, "c": 30}

print('values() : ', list(my_dict.values()))
print('keys() : ', list(my_dict.keys()))

print('values() : ', tuple(my_dict.values()))
print('keys() : ', tuple(my_dict.keys()))

# values() :  [10, 20, 30]
# keys() :  ['a', 'b', 'c']
# 
# values() :  (10, 20, 30)
# keys() :  ('a', 'b', 'c')
```


Доступ к элементам словарей
---

Есть 2 способа получить значение из словаря:

1) Метод `get()` - метод удобен тем что не дает ошибки `KeyError`
принимает ключ и возвращает значение по этому ключу если он есть,
если по такому ключу ничего нет, то возвращает `None`, 2 аргумент,
указывает какое значение вернуть если не найдено.

   
2) Получение по ключу `dict['key']` этот метод работает так же как и 
первый, но в случае если такого ключа нет, то выдает ошибку `KeyError`
также значение по дефолту нет.
   
```python
    person = {'name': 'Phill', 'age': 22}

    # Тут будет ошибка
    # print(person['some-value'])

    print('Name: ', person.get('name'))
    print('Age: ', person.get('age'))
    print('Salary: ', person.get('salary'))
    print('Salary: ', person.get('salary', 0.0))

    # Вывод
    # Name:  Phill
    # Age:  22
    # Salary:  None
    # Salary:  0.0
```

---

Методы Словарей
---

1) `keys()` - Возвращает все ключи в виде специальной последовательности,
которую можно в явном виде, преобразовать к обычному списку, кортежу ...

2) `values()` - Возвращает все значения в виде специальной 
последовательности, которую можно в явном виде, преобразовать к обычному 
списку, кортежу ...

3) `items()` - Возвращает список в котором находятся кортежи всех 
   объектов с ключами и значениями, по сути этот метод соединяет в себе
   метод `keys()` и `values()` просто заносит их еще и в кортеж.

---

Ключи для словарей
---

В качестве ключей для словарей можно использовать только неизменяемые 
типы данных, строки, числа и кортежи, но при условии, что кортежи 
содержат в себе только неизменяемые типы данных:

```python
    ml = {"one": 10, "two": 20, 3: 30, (1, 3): 40}

    print(ml)
    
    print("ml['one'] = ", ml['one'])
    print("ml[3]  = ", ml[3])
    print("ml[(1, 3)] = ", ml[(1, 3)])

    # {'one': 10, 'two': 20, 3: 30, (1, 3): 40}
    
    # ml['one'] =  10
    # ml[3] =  30
    # ml[(1, 3)] =  40
```

Если используем числа, то так и записываем числа, если кортежи, то так
кортежи и записываем.

---

Итерация по словарю
---

Когда мы итерируемся по списку циклом `for`, то имеем дело с копией
элементов в последовательности, если хотим менять оригиналы в самом 
списке, то следует использовать итерацию по числам в списке, то есть
конструкцию `for i in range(len(my_list))`. 

Но для словарей все иначе, в словарях при использовании оператора
`in` или `for` то проверка будет идти не со значениями, а с ключами
в словарях, таким образом используя словари в цикле `for`, мы будем
обращаться к элементу словаря по ключу, таким образом работая со
словарями внутри цикла `for` мы сразу имеем дело с оригинальными 
данными из словаря, а не с их копией, полностью противоположная 
ситуация со списками:

```python
   my_dict = {'a': 10, "b": 20, "c": 30}
   
   print('my_dict = ', my_dict)
   
   for key in my_dict:
       my_dict[key] += 1
       print(my_dict[key])
   
   print('my_dict = ', my_dict)
   
   # my_dict =  {'a': 10, 'b': 20, 'c': 30}
   # 
   # 11
   # 21
   # 31
   # 
   # my_dict =  {'a': 11, 'b': 21, 'c': 31}
```



