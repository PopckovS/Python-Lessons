Множества `set` и `frozenset`
---

Множества `set`
---

Множества это контейнер содержащий уникальные не повторяющиеся 
элементы в случайном порядке, обозначается через `{ }` фигурные
скобки.

Создание множества
---
Множества записываются в фигурные скобки `{ }` такие же как 
и у словаря, но словари имеют ключи доступа, записываются как
`key : value` ключ: значение в то время как у множества ключей нет.

При создании переменной в фигурных скобках, если в фигурные 
скобки не занесено значения то будет создан пустой словарь,
если было указано значение и только значение без ключа, то 
будет создано множество.

Это словарь 

```python
    var1 = {}

    print(var1)
    print(type(var1))

    # Вывод
    # {}
    # <class 'dict'>
```

А это уже множество: 

```python
    var1 = {1}
    print(var1)
    print(type(var1))

    # Вывод
    # {1}
    # <class 'set'>
```

Операции над множествами
---

1) Множества можно сравнивать при помощи обычного оператора `==`
вот таким образом:

```python
    set1 = {1,2,3,4,5}
    set2 = {1,2,3,4,5}

    if set1 == set2:
        print("да")
    else:
        print("нет")

    # Вывод
    # да
```

2) Также поддерживается сравнение, содержит ли одно множество
в себе все элементы другого:

```python
   set1 = {1, 2, 3, 4, 5, 6}
   set2 = {1, 2, 3, 4, 5}
   
   print("set1 > set2 = ", set1 > set2)
   print("set2 > set1 = ", set2 > set1)
   
   # Вывод
   # set1 > set2 =  True
   # set2 > set1 =  False
```

---

Методы множеств
---

1) `set.add(elem)` - добавляем элемент в множество
   

2) `set.remove(elem)` - Удаляет элемент из множества, и 
выдает ошибку KeyError если его не существует.
   

3) `set.discard(elem)` - Удаляет и не вызывает ошибки
   

4) `set.pop()` Удаляет некий элемент из множества, по 
   скольку множества не отсортированы, удаляет рандомный 
   элемент.


5) `set.clear()` - очищает множество.

---

Множества `set`
---

Создать множества можно 2 способами, либо при помощи метода `set()`
в который передан список, из которого будет создано множество.

Либо при помощи фигурных скобок `{1, 2, 3}` это схоже с обьявлением 
словаря, но словарь имеет `ключи:занчение` в то время как множество
имеет только значения.

```python
    my_set_one = set( [1, 2, 3, 4, 5] )
    my_set_two = {1, 2, 3, 4, 5}
```

Множества могут содержать набор уникальных элементов, создается при
помощи функции `set()`, чтобы добавить новый элемент, требуется
использовать метод `.add()`  

```python
    my_set = set()
    my_set.add(1)

    print(my_set)

    # Вывод 
    # {1}
```

При выводе множества можно увидеть что оно записывается в фигурных 
скобках, схожим со словарями образом, только словари содержат ключи
и именно ключи должны быть уникальными,  

```python
    my_set = set()
    my_set.add(1)
    my_set.add(2)
    my_set.add(2)
    
    print(my_set)
    
    # Вывод
    # {1, 2}
```
    
При попытке добавить уже существующее значение в множество, оно
добавлено не будет, так как множество может содержать только
уникальные значения.

При превращении списка в множество, все повторяющиеся элементы
из списка будут автоматически удалены, таким образом множество
можно использовать как инструмент для получения списка с уникальными
элементами.

---

Доступ к Множествам
---

Множества не поддерживают доступа к элементам по их индексу.

```python
    my_set = set([1, 2, 33, 4, 4, 11, 22, 3, 3, 2])
    print(my_set[0])

    # Вывод
    # TypeError: 'set' object does not support indexing
```

Но к ним можно обращаться при помощи итерации циклом for:

```python
   my_set = set([1, 2, 33, 4, 4, 11, 22, 3, 3, 2])
   
   for elem in my_set:
       print(type(elem), elem)
   
   # <class 'int'> 1
   # <class 'int'> 2
   # <class 'int'> 33
   # <class 'int'> 4
   # <class 'int'> 3
   # <class 'int'> 11
   # <class 'int'> 22
```

---

Удаление элемента из множества
---

Удалить элемент множества можно 2 способами.

1) `discard()` - Удаляет элемент и не выдает ошибку, если элемент 
не был найден в множестве.

```python
   num_set = {1, 2, 3, 4, 5, 6}
   print(num_set)
   
   num_set.discard(3)
   print(num_set)
   
   num_set.discard(3)
   print(num_set)
   
   # {1, 2, 3, 4, 5, 6}
   # {1, 2, 4, 5, 6}
   # {1, 2, 4, 5, 6}
```

2) `remove()` - Удаляет элемент и выдает ошибку если элемент не был 
   найден.

```python
   num_set = {1, 2, 3, 4, 5, 6}
   print(num_set)
   
   num_set.remove(3)
   print(num_set)
   
   num_set.remove(3)
   print(num_set)
   
   # {1, 2, 3, 4, 5, 6}
   # {1, 2, 4, 5, 6}
   # Traceback (most recent call last):
   #   File "test.py", line 7, in <module>
   #     num_set.remove(3)
   # KeyError: 3
```

Если мы попробуем удалить элемент при помощи метода `remove()` при том
что этого элемента не существует, то мы получаем ошибку типа `KeyError`

3) `pop()` - Этим методом тоже можно удалить элемент из множества, но 
мы не можем сказать какой из элементов будет удален.

4) `clear()` - Удаляет все элементы из множества, но не удаляет само
множество.

---

Обьеднение множеств `union()`
---

Обьеденить множества можно при помощи метода `union()`

```python
    set_one = set([1,2,3,4,5])
    set_two = set([6,7,8,9,10])

    set_new = set_one.union(set_two)
    print(set_new)

    # Вывод
    # {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```

Видим что оба множества обьеденились в одно.

Также метод union может обьеденить 3 множества:

```python
    x = {1, 2, 3}
    y = {4, 5, 6}
    z = {7, 8, 9}

    output =  x.union(y, z)
    
    print("Вывод еще одного обьедененного множества: ", output)

    # Вывод еще одного обьедененного множества:  {1, 2, 3, 4, 5, 6, 7, 8, 9}
```

---

Генератор множества
---

Генерировать можно не только списки, но и множества:

```python
    my_list = [ i*10 for i in range(10) if i%2==0]
    print(my_list)

    my_set = { i*10 for i in range(10) if i%2==0 }
    print(my_set)

    # Вывод
    # [0, 20, 40, 60, 80]
    # {0, 40, 80, 20, 60}
```

Способ генерации списков и множеств одинаков, но множества не
отсортированы, так что имеют произвольный порядок.

---

Неизменяемые множества `frozenset`
---

Тут ситуация как и с `list` и `tuple` единственное
отличие `set` от `frozenset` в том что он не изменяем.
