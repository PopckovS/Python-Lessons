Работа с файлами
---

Работа с файлами происходит при помощи функции `open()` по дефолту
она принимает название файла, а вторым аргументом передает `r`
на чтение, но если фала не существует то его читать и не выйдет.

Для создания файла открываем его с параметром `w` или `w+` и он 
будет создан. 


Создаем файл и записываем в него 3 строчки:
```python
 f = open(file_name, "w")
 f.write("Первая строчка\nВторая строчка\nТретья строчка")
 f.close()
```
    
Открываем файл и выводим из него все содержимое, далее сбрасываем
указатель на начало файла:

```python
 f = open(file_name)
 print(f.read())
```
    
Другой способ вывода содержимого файла:
```python
  for line in f:
     print(line)
```

---

Методы
---

1) `open()` - открывает / создает файл.
2) `f.write('Текст')` - записывает в файл данные.  
3) `f.close()` - Закрывает файл.
4) `f.read()` - Выводит весь текст из файла.
5) `f.seek(int)` - Переносит курсор на выбранный символ файла,
   нулевой символ это обозначение начала файла. В процессе работы 
   с файлом мы считываем из него информацию, и курсор перемещается,
   после того как курсор доходит до конца файла, его надо вернуть 
   в начало файла, чтобы иметь возможность считать его заново. 
6) `f.readlines()` - Считывает все строки файла и возвращает их 
    в виде списка, где каждая строка это один элемент списка.

---

Перемещение / Удаление файла. Модуль OS
---

Для этого можно использовать модуль `os`

1) `os.path.isfile("Путь к файлу")` - Метод модуля проверяет, 
существует ли такой файл и возвращает `True/False`


2) `os.path.isdir("Путь к директории")` - Проверяет, существует 
   ли такая директория и возвращает `True/False`


3) `exists()` - Проверка существования.


4) `os.remove("/путь/к/файлу")` Удаляет файл.


5) `os.rename("/путь/к/файлу", "/новый_путь/к/переименованному_файлу")`
переименовывает файл.

---

Файлы ввод/вывод
---

**Дескриптор файла** - это уникальный ID номер этого файла, если 
файл уже открыт при помощи команды `open()` то даже если этот 
файл был переименован или удален или еще что ... то это все не 
повлияет на работу, ибо на момент открытия файла у нас был к нему
доступ и мы уже успели начать с ним работу, по дефолту при открытии
файла в Linux библиотека `libc` открывает 3 файла дескриптора с 
номерами 0, 1, 2

0 - `STDIN` - Файл с вводом данных в приложение.

1 - `STDOUT` - Файл для вывода данных, к примеру файл в который будет 
произведен вывод команды `print()`

2 - `STDERR` - Файл для записи данных об ошибке.

Когда же мы открываем файл с которым мы будем работать, то он получает
номер 3

Интерпретатор Python предоставляет нам три текстовых файла называемых 
стандартными потоками ввода / вывода, все они находятся в модуле sys:
`sys.stdin`, `sys.stdout`, `sys.stderr` все эти три потока открыты и в 
текстовом режиме, в чем можно убедиться вызвав их и увидев что
они являются объектами класса `TextIOWrapper` 

`stdin` - точка входа, файл что запускает в работу нашу программу,
для получения данных из вне в программу этого файла используется
функция `input()`. Для записи в `stdout` и `stderr` функция `print()`

---

Функция open()
---

Функция `open()` открывает дескриптор файла для работы с ним, по 
дефолту файл открывается с доступом `r` чтение из файла, можно 
поменять на `w` запись в файл, также файлы различаются на 2 
типа: текстовые и бинарные. Разница соответствующая, чтобы обратиться
к файлу как к бинарному следует дополнить модификатор символом `b`.

Если мы используем модуль `Pickles` для сериализации данных и
сохранения то значит данные будут сохранены в бинарном виде, 
то есть файл должен быть открыт с модификатором `b`

Если посмотреть на то что возвращено, то можно увидеть что файл
является объектом класса `_io.TextIOWrapper` по дефолту кодировка
зависит от самой системы, на Linux это UTF-8 

    <_io.TextIOWrapper name='test.py' mode='r' encoding='UTF-8'>
  
1) `_io.TextIOWrapper` - файл с текстом
2) `_io.BufferedReader` - бинарный на чтение
3) `_io.BufferedWriter` - бинарный на запись

---

Методы файлов
---

`file.read()` - Читывает все строчи из файла сразу, если предать
число то возвращает количество указанных символов.

`file.readline()` - Читает из файла по одной строчке за раз.

`file.closed` - Возвращает True/False закрыт дескриптор файла или нет.

`file.close()` - Закрывает дескриптор файла, предварительно вызывая
метод `file.flush()` для перевода данных в жесткий диск из буфера.

`file.write()` - Записывает в файл строчку.

`file.name` - Возвращает название файла.

`file.flush()` - Все данные которые мы записываем в файл, с начал 
записываются в буфер и только потом при вызове метода `close()` 
попадают из буфера на жесткий диск, этот же метод вызывает перенос 
всего накопленного из буфера в файл не дожидаясь закрытия дескриптора.

`file.mode` - Возвращает модификатор с которым открыт файл.

`file.fileno()` - Возвращает номер файлового дескриптора, связанного
с файлом, число 3.

`file.seek(0)` - Управляет позицией итератора, передача аргумента 0 
приведет к возвращению в начало файла.

---

**Работа с файлами:**

Файлы по сути являются итерируемыми объектами, то есть каждое
обращение на чтение из этого объекта возвращает строчку и сдвигает
итератор на следующую строчку, и так далее пока не дойдем до конца
файла `EOF`.

3 способа пройтись по строкам файла:

```python
    file = open(file_name, 'r')

    # Первый способ прочитать все сразу
    print(file.read())

    # Второй способ прочитать по одной строчек за раз
    # то есть проитерироваться как по итерируемому обьекту
    print(file.readline())
    print(file.readline())
    print(file.readline())

    # Схож со вторым способом, итерация по строчке методом for
    for line in file:
        print(line)
```

Когда нам нужно запись данные в файл, мы можем сделать это 2
способами, при помощи стандартного метода `file.write(str)`

```python
    file_name = 'test.txt'
    file = open(file_name, 'w')
    file.write(f'В файл записан этот текст !')
    file.close()
```

Второй способ заключается в переопределении вывода функции `print()` 
эта функция имеет параметр `file` по дефолту установленный в
`sys.stdout` сама переменная модуля `sys.stdout` содержит:

```python
    print(sys.stdout)

    # Вывод
    # <_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>
```

То есть по дефолту `sys.stdout` параметром `name='<stdout>'` указывает
на вывод данных в терминал, откуда эта программа и вызывается, 
когда мы смотрим что содержится в открытом файле:

```python
    file = open('test.txt', 'w')
    print(file)
    
    # Вывод
    # <_io.TextIOWrapper name='test.txt' mode='w' encoding='UTF-8'>
```

То тут можно увидеть что для работы с терминалом и в работе с файлами
используется один и тот же класс по работе с вводом / выводом, просто
указывается в функции `open()` атрибут `file=file` мы просто указываем
что вывод текстовых данных нужно перенаправить из терминала в указанный 
текстовый файл.

---

Модуль _io и базовый класс _IOBase
---

В Python есть модуль `io` этот модуль работает с потоками, все
начинается с базового класса `object` от него наследуется `_IOBase`

`_IOBase` - базовый класс по работе с вводом / выводом данных для
потоков, от этого базового класса, наследуются два других 
`_BufferedIOBase` и `_TextIOBase` каждый из них является основой
для классов по работе с данными, текстовыми и байтовыми.

---

**_BufferedIOBase**

`IOBase` от него наследуется `_BufferedIOBase` от которого наследуется: 

    BufferedRandom - Когда файл открыт как бинарный и с `+` как с `w` так и с `r`
    BufferedReader - Используется когда мы открываем файл на бинарное чтение.
    BufferedWriter - Используется когда мы открываем файл на бинарную запись.
    BufferedRWPair 
    BytesIO
    _RawIOBase
    FileIO

---

**_TextIOBase**

`IOBase` от него наследуется `_TextIOBase` от которого наследуется: 

    StringIO - класс для работы со строчками.
    TextIOWrapper - главный класс по работе с текстовыми файлами.

---

Модуль io и модуль _io
---

В Python одно нижнее подчеркивание дает модификатор `protected`, тоже
и относится к классам, есть два модуля `io` и `_io` один определяет
стандартное поведение для потоков ввода / вывода, а модуль `io` создан
для публичного доступа, но имеет тот же функционал унаследованный от
`_io` так образом есть как модуль для дефолтного поведения, так и 
модуль для публичной работы.

Используя классы `io.StringIO` и `io.BytesIO` можно работать как со
строками, так и с байтами.