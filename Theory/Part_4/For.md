Цикл `for` и функция `range()`
---
---

Цикл `for` может обходить любой итерируемый обьект.

В других языках это соответствует циклу `foreach` то есть тут for
именно итерируется по некой последовательности, а не по просто 
проверяет условие как `for` в других языках. По этому используется
генератор последовательности `range()` чтобы сгенерить что-то по 
чему можно итерироваться.

Следующие 2 метода эквивалентны:
```python
    for number in range(5):
        print('number = ', number)

    for num in [0, 1, 2, 3, 4]:
        print('num = ', num)

    # Вывод
    # ('number = ', 0)
    # ('number = ', 1)
    # ('number = ', 2)
    # ('number = ', 3)
    # ('number = ', 4)
    
    # ('num = ', 0)
    # ('num = ', 1)
    # ('num = ', 2)
    # ('num = ', 3)
    # ('num = ', 4)
```
---
Цикл `for` при работе со словарями `dict`
---
Цикл `for` применим к словарям, использование словаря эквивалентно
вызову метода `.keys()` который возвращает список из ключей 
словаря.

Следующие 2 метода `for` эквивалентны:
```python
    a_dict = {"one": 1, "two": 2, "three": 3}
    print('a_dict.keys() = ', a_dict.keys())
    print('type = ', type(a_dict.keys()))

    for key in a_dict:
        print(key)

    for key in a_dict.keys():
        print(key)

    # Вывод
    # ('a_dict.keys() = ', ['three', 'two', 'one'])
    # ('type = ', <type 'list'>)
    # three
    # two
    # one
    # three
    # two
    # one
```

---
Блок `else` в цикле `for`
---
У циклов есть блок `else` который исполняется всегда если не было
использовано оператора `break`. Такая же логика используется и в
`while`
---


---

Функция `range()` и `arange()`
---
---
Первоначально в версии python2 существовало 2 метода `range()` и
`xrange()` метод range() просто создавал обычный список со всеми
значениями, метод `xrange()` являлся генератором, спец класса
`range` и как обычный генератор, создавал новый элемент 
последовательности только при обращении к нему, что позволяло 
экономить память, и не хранить созданный список в памяти полностью.

Метод `xrange()` работал лучше, чем обычный `range()`, дело в том 
что python сам по себе очень прожорливый на память язык 
программирования, к примеру обычный пустой список в python весит
`64 байта`

```python
    import sys

    list_1 = list()
    print('list_1 = ', list_1)
    print('Empty list in bytes = ', sys.getsizeof(list_1))

    # Вывод
    # ('list_1 = ', [])
    # ('Empty list in bytes = ', 64)
```

Если же мы используем для генерации списка range() из старой 
версии python2, для генерации 1000 элементов, то получим 
следующий результат:

```python
    import sys

    list_2 = list(range(1, 1001))
    print('list_2 = ', list_2)
    print('Not empty in bytes = ', sys.getsizeof(list_2))
    
    # Вывод
    # list_2 =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ...
    # 995, 996, 997, 998, 999, 1000]
    # Not empty in bytes =  9112
```

Можно увидеть что хранить весь список в памяти просто невыгодно,
он занимает `9112 байт` по этому и использовался метод `xrange()`
ибо будучи генератором, он не хранил всю последовательноcть в 
памяти, а генерировал новое значение сразу при обращении, далее
в версии python3 метод `range()` был удален, а метод `xrange()`
был переименован в метод `range()` с ним мы теперь и работаем.

Если запустить следующий код в версии Python-2 то, можно увидеть 
разницу методов.

```python
    func_range = range(1, 11)
    print('type(func_range) = ', type(func_range))
    print('func_range = ', func_range)

    func_xrange = xrange(1, 11)
    print('type(func_xrange) = ', type(func_xrange))
    print('func_xrange = ', func_xrange)

    # Вывод
    # ('type(func_range) = ', <type 'list'>)
    # ('func_range = ', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    
    # ('type(func_xrange) = ', <type 'xrange'>)
    # ('func_xrange = ', xrange(1, 11))
```

Тут и можно увидеть что метод `range()` генерирует список, то время
как `xrange()` создает спец тип данных.


---
Современный метод `range(start, end, step)`
---
---
Метод `range()` генерирует последовательность элементов, с 
заданным шагом:

```python
    var_1 = range(1, 11)
    print('var_1 = ', var_1)

    var_2 = range(1, 11, 2)
    print('var_2 = ', var_2)

    var_3 = range(1, 11, -1)
    print('var_3 = ', var_3)

    # Вывод
    # ('var_1 = ', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    # ('var_2 = ', [1, 3, 5, 7, 9])
    # ('var_3 = ', [])
```
---
Метод `range()` создает не список, а особый обьект, по которому
можно итерироваться при помощи цикла `for` но списком не является,
и для превращения в список требуется указать это явно:

```python
    some = range(1, 11)
    print(some)
    print(type(some))

    my_list = list(some)
    print(my_list)
    print(type(my_list))

    # Вывод
    # range(1, 11)
    # <class 'range'>
    
    # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    # <class 'list'>
```
---



