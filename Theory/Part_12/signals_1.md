Signals - сигналы
---
---

В Django присутствует такой механизм как `диспетчер сигналов`.
Сигналы оповещают о том что происходит некоторое событие в
некоторой части приложения.

Есть ряд типов сигналов:

>- **post_save**,  **pre_save** - происходит когда сохраняют
   > модель
> 
> 
>- **post_delete**, **pre_delete** - происходит когда удаляют
   > модель
> 
> 
>- **request_finished**, **request_started** - когда отправляют
   > HTTP запрос

Суть в том что мы регистрируем функцию, которая будет вызываться
автоматически при одном их произошедших событий.

---

Есть 2 способа которым можно зарегистрировать такие функции:

>1. Использовать `Signal.connect()` для регистрации функции.
> 
> 
>2. Использовать декоратор `receiver`

---

Если используем декоратор `@receiver` то передаем в параметры, 
класс функции сигнала, и модель к которой будет привязан сигнал.

Сама функция сигнала принимает 2 параметра, `sender` это сам класс
модели, и `instance` это созданный обьект модели, на который сигнал
и среагировал.

Пример сигнала срабатывающего после создания/обновления записи
в модели `ImagesModel` в файле `models.py`
```python
from django.dispatch import receiver, Signal
from django.db.models.signals import post_save, 
                                     pre_delete, 
                                     pre_save

@receiver(post_save, sender=ImagesModel)
def on_change_post(sender, instance, **kwargs):
    """Сигнал post_save - Создаем мини версию изображение"""
    if instance.big_image and os.path.isfile(instance.big_image.path):
        create_small_img(instance, size=500)
```
---
Когда исполняется сохранение обьекта модели, начала отрабатывает 
сигнал `pre_save` потом метод сохранения самой модели `save` и 
после сигнал `pre_save`. Но все эти 3 операции происходят не по
отдельности, а представляют из себя один блок, и само физическое
сохранение модели, записью в БД на жесткий диск, происходит в 
самом конце после метода `pre_save`

---

Как избежать рекурсии при сохранении модели в сигналах ?
---

Представим такую ситуацию, нам надо сохранить модель и после этого
сделать что-нибудь с сохраненными данными, и снова сохранить модель,
сделать это мы можем в методе `post_save` но ! Если мы в методе 
`post_save` вызовем метод `objModel.save()` то это вызовет 
рекурсию.

Избежать этого можно 2 способами:

1. Вместо метода `save()` использовать метод `update()` этот метод
не вызывает метода `save()` в работу на обновление всей записи, а
только обновляет одно единственное поле, и это не вызовет рекурсии.

Пример:
```python
@receiver(post_save, sender=Images)
def on_change_post(sender, instance, **kwargs):
    Images.objects.filter(pk=instance.pk).update(title='Новое название')
```


2. Второй способ это просто присвоить нужному полю модели, нужное
значение, и все ! Это работает по скольку само сохранение в БД
происходит после метода `post_save` 

Пример:
```python

@receiver(post_save, sender=Images)
def on_change_post(sender, instance, **kwargs):
    instance.title = 'Новое название'
```
