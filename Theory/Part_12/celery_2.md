Celery создание приложения
---

Все начинается с создания Celery приложения, это приложение должно
быть доступно в других программах, так что оформить приложение на 
Celery требуется в специальный модуль, который обычно называют 
`tasks.py` если программа маленькая то этого достаточно, если
нет то оформляют в отдельный пакет.

Создадим файл tasks.py:

```python
from celery import Celery

# Название модуля и выбор брокера сообщения
# app = Celery('tasks', broker='pyamqp://guest@localhost//')
app = Celery('tasks', broker='redis://localhost:6379/0')

@app.task
def add(x, y):
    return x + y
```

Первый параметр это название текущего модуля.

При создании приложения вторым параметром мы указываем используемый
брокер сообщений, можно просто вынести эти настройки в файл 
`settings.py` и импортировать настройки 

    CELERY_BROKER_URL = 'redis://127.0.0.1:6379/0'

А можно указывать и напрямую при создании приложения

```python
    app = Celery(
                'django_celery', 
                broker_url='redis://127.0.0.1:6379/0'
                )
```

В этом примере мы создали одну задачу с названием `add` это 
функция, что оборачивается декоратором `@app.task`

---

Вызов задачи Celery
---

Когда мы создали задачу, что может выполняться в фоновом режиме, 
совместно с брокером сообщений Redis, теперь ее можно вызвать на
исполнение.

Для вызова нашей задачи используем метод `delay()` который доступен
теперь когда функция выполнения задачи привязана к Celery.

Запуск задачи через Celery

```python
from tasks import add
add.delay(4, 4)
```

Вызов в работу такой задачи возвращает экземпляр класса `AsyncResult`
через этот класс мы можем получить состояние задачи, ожидания
завершения задачи или получения ее возвращаемого значения (или, 
если задача не удалась, для получения исключения и трассировки).

---

Получение результатов
---

Существует 2 отдельные темы, это `Брокер Сообщений` и 
`Бэкэнд Результатов` 

```python
    app = Celery(
                'tasks', 
                backend='redis://localhost', 
                broker='redis://localhost:6379/0'
    )
```

Если мы хотим отслеживать задачи или нужно возвращать результат 
работы, тогда Celery должен где-то хранить или отправлять состояния,
чтобы их можно было получить позже. Есть несколько встроенных
бэкэндов результатов на выбор:

- `SQLAlchemy` / `Django ORM`
- `Memcached`
- `RabbitMQ` 
- `Redis`

И так, запустили функцию, получаем результат:

```python
result = add.delay(4, 4)

print(result.ready())

    # Вывод
    # False
```

Метод `ready()` возвращает результат, выполнена работа или нет.

У каждой запущенной задачи есть ее уникальный `UUID` доступный по 
`id` атрибуту.
```python
result.id
d6b3aea2-fb9b-4ebc-8da4-848818db9114
```

Так как же узнать, провалилась ли задача? Это можно узнать,
посмотрев на состояние задач :

```python
res.state

# 'FAILURE'
```

```python
res.failed()
# True

res.successful()
# False
```

---













