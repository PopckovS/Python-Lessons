## Python и ООП 3

### Наследование
Все классы в питоне наследуются от базового `object` во 2 версии 
это делалось явно, начиная с 3 версии это происходит автоматически.

Есть класс `class Prop` чтобы унаследоваться от него, указываем его в
дочернем классе, в скобках `class Line(Prop)`

Когда в классе Point создается метод конструктор:

    class Prop:
        def __init__(self, start, end, color, width):
            print("Метод __init__ класса Prop")
            self._start = start
            self._end = end
            self._color = color
            self._width = width

Если мы унаследуемся от него классом Line, и в самом классе Line
мы не создаем метода конструктора, то по дефолту будет использоваться
метод конструктор родительского класса:

     class Line(Prop):
        def drawLine(self):
            print(f"Рисуем линию: {self._start}, {self._end}," \
                   f" {self._color}, {self._width}")

Если мы хотим переопределить метод конструктор в Line, или хотим
добавить дополнительный функционал, то мы можем сделать 
это 2 способами:

1) `Point.__init__(self, *args)`
    Этот метод не правильный, его можно использовать, но 
   указание конкретного класса родителя приводит к путанице в 
   случае множественного наследования. 
   
Обратим внимание что данный способ вызова требует передачу `self`

2) `super().__init__(*args)`
    Этот метод правильный, он сам извлекает из стека наследуемых 
   классов правильный.
   
Обратим внимание что данный способ вызова не требует передачу `self`
   
### Модификатор доступа protected
Создается при помощи одного нижнего подчеркивания, и говорит 
программисту что этот атрибут следует использвоать только в нутри 
класса, или его дочерних классах, но по факут это никак не ограничивает
доступ к атрибуту, и обращаться к нему можно из вне.

Данный модификатор просто декоративный.


### Перегрузка методов
Перегрузка методов - Выполнять разный функционал в зависиости от 
количества переданных аргументов.

Если в дргуих языках типа `C#` это подразумевает еще и созлание нового 
одноименного метода, то в Питоне это делается просто путем условий.

К примеру так:

    def setCoords(self, start:Point, end:Point=None):
        if end is None:
            if start.check_int():
                self._start = start
            else:
                print("Координаты должны быть целочисленными")
        else:
            if start.check_int() and end.check_int():
                Point.set_coord(self, start, end)
            else:
                print("Координаты должны быть целочисленными")

Таким образом мы теперь можем вызывать метод как с 2 так и с 1 арг.

### Абстрактные методы
Абстрактные методы - методы которые должны быть обезательно реализованы 
в дочерних классах.

Сделать это можно путем вызова исключения, метод будет всегда давать 
исключение, до тех пор пока его не переопределят, таким образом мы 
заставляем переопределить этот метод в дочерних классах.

Пример реализации:
 
    def drawLine(self):
        raise NotImplementedError(
            "В дочернем классе должен быть переопред метод drawLine()"
        )


### Паттерн singleton

### Статические методы
Создаются при помощи декоратора `@staticmethod` и также метод
более не требует использования параметра `self`

Пример статического метода:

    @staticmethod
    def getCounter():
        return Point.__count

По скольку у метода более нету аргумента `self` мы более не можем
оперировать к обьектам, только к статике класса.

Создадим класс который будт при помощи статич атрибута считать 
количество экземпляров самого класса.

    class Point:
        __count = 0

        def __init__(self, x, y):
            Point.__count += 1
            self.x = x
            self.y = y

        @staticmethod
        def getCounter():
            return Point.__count

    pt1 = Point(1, 2)
    pt2 = Point(10, 20)

    def newGetCounter():
        return 55

    pt1.getCounter = newGetCounter

    print(pt1.getCounter())
    print(Point.getCounter())

    // Вывод
    55
    2

Также можно увидеть на этом примере что можно переопределить метод из вне,
внеся в него значение другова метода.

    def newGetCounter():
        return 55

    pt1.getCounter = newGetCounter

Сдклав это мы переопределили метод класса на другой.

























