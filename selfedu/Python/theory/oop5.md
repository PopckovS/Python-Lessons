## Python и ООП 5

### Паттерн 'Моносостояние'
Моносостояние - это паттерн программирования при котром есть несколько 
обьектов одного класса, и все экземпляры этого класса имеют одни 
общие атрибуты, любая работа в получении или изменении или удалении
этих атрибутов, приводит к такомуже изменению этих атрибутов у всех
других экземпляров этгого класса.

Тоесть у нас есть несколько обьектов одного и тогоже класса, и все эти
обьекты ссылаются на одни и теже данные.

Реализация происходит через статический атрибут класса ссылка на который 
присваевается каждому новому созданному обьекту.

    class Monopattern():
        __atributs = {
            'id': 0,
            'name': None
        }

        def __init__(self):
            self.__dict__ = Monopattern.__atributs

    x1 = Monopattern()
    x2 = Monopattern()

    print(f'x1:{x1.__dict__} x2:{x2.__dict__}')

    x1.id = 15
    x2.name = 'Hello world'

    print(f'x1:{x1.__dict__} x2:{x2.__dict__}')

    // Вывод
    x1:{'id': 0, 'name': None} x2:{'id': 0, 'name': None}
    x1:{'id': 15, 'name': 'Hello world'} x2:{'id': 15, 'name': 'Hello world'}

### Методы обьектов, @classmethod и @staticmethod
Существует 3 метода, это может быть обычный динамический метод,
который вызывается у обьекта и имеет один обезательный метод `self`

Также по мимо них, существует 2 типа других методов, которые задаются
при помои декараторов.

@classmethod - метод с таким декоратором требует получение аргумента
`cls` который содержит в себе ссылку на этот класс, этогоже можно 
добиться при помощи указания названия класса.

    @classmethod
        def class_meythod(cls):
            return cls.STATIC_NAME

@staticmethod - обычный декоратор для метода, он не требует никаких 
специальных аргументов, и может обращаться к значениям класса при 
помощи указания названия этого класса.

     @staticmethod
        def static_method():
            return Point.STATIC_NAME


По существу это выглядит так, @classmethod - используется для методов которые
будут работать с данными класса, а @staticmethod используется для операций
тематически связанных к этим классом, однако в любом их них на самом деле можно 
делать что угодно, и работать с любыми обьектами класса, если передать обьект 
класса в эти методы, чтобы использовать его как заменитель `self`

### Атрибут __slots__ 
По дефолту класс реализует атрибут __dict__ это словарь в котором он 
будет содержать все атрибуты обьекта.

Можно определить список или кортеж __slots__ как атрибут класса, и обьявить 
в нем названия всех переменных которые можно обьявлять и использовать в обьекте
такого класса, при этом атрибут __dict__ автоматически не создается.

Это позволяет экономить память в программе, у обьектов и атрибутов есть такой 
метод как `__sizeof__()` который возвращает размер затрачиваемой памяти на 
хранение данного элемента:

        class One:
        """Заменяет __dict__ атрибутом __slots__"""
        __slots__ = ['x', 'y']

        def __init__(self, x, y):
            self.x = x
            self.y = y

        def get_coord(self):
            return self.x, self.y

    class Two:
        """Имеет атрибут __dict__"""

        def __init__(self, x, y):
            self.x = x
            self.y = y

        def get_coord(self):
            return self.x, self.y

    x1 = One(10, 20)
    x2 = Two(100, 200)

    print('Класс с __slots__ :', x1.__sizeof__())
    print('Класс с __dict__ :', x2.__sizeof__(), x2.__dict__.__sizeof__())

    // Вывод
    Класс с __slots__ : 32
    Класс с __dict__ : 32 88

Как можно увидеть, класс у которого есть атрибут __dict__ занимает на 88 байт 
памяти в кто время как у другова класса, атрибута __dict__ вовсе нету и памяти 
он не занимает вабще. 











