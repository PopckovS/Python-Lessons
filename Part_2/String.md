 Строки 
---
Строки это обьекты своих классов, у строк есть такое свойство как
`immutabillity` которое отвечает за изменяемость обьекта, и строки
являются неизменяемым обьектом.

Но можно создать новую строку путем конкатенации с помощью `+`

---

Оператор %
---
При помощи специального оператора `%s` можно форматировать строки, вставлять 
в них данные, есть 2 формы записи этого метода:

```python
    hello = 'Hello World'

    print('Тут будет вставленеа переменная %s' %(hello) )
    print('Тут будет вставленеа переменная %s' %hello )
```
    
То есть видим что данный оператор помогает нам форматировать строку, также он
позволяет использовать параметры, которые изменяют формат данных. 

Параметр `%1.2f` отвечает за вывод типа `float`. Цифра после точки указывает 
сколько будет символов после запятой. Первая цифра указывает минимальное 
количество символов которое будет перед запятой.

```python
    var = 145.137
    print('Число = %1.10f' %(var) )
    
    # Вывод
    # Число = '145.137'
```
    
Другой параметр это `%r` если первый `%s` использует функцию str() для 
конвертации, то второй использует функцию `repr()`

```python
    var = '145.137'
    print('Число = %1.10f' %(var) )

    # Вывод
    # Число = '145.137'
```
    
Можно форматировать множество обьектов этими операторами, обратим внимание что 
элементы передаваемые в строку являются кортежем.

```python
    print('0 = %s, 1 = %s, 2 = %s ' %('hi', 'two', 3))

    # Вывод
    # 0 = hi, 1 = two, 2 = 3  
```
    
---

Методы самих строк
---

1) isupper() - проверка является ли вв ерх регистре
2) upper() - возведение в верх регистр
3) islower() - проверка явл ли ниж регистр
4) lower() - переводит в низ регистр
5) split('char') - принимает символ по которому разделяет список на части
6) format() - вставляет в строку указанные данные

---


Методы строк
---
1) strip() - Удаляет пробелы с лева и справа в строке.
2) lstrip() - Удаляет пробелы с лева.
3) rstrip() - Удаляет пробелы с права.

```python
    string = "   Hello World   "

    string.strip()  
    string.lstrip() 
    string.rstrip() 

    # Вывод
    # "Hello World"
    # "Hello World   "
    # "   Hello World"
```
    
4) `split(str value)` - Метод разбивает строку по указанной подстроке.
    Это очень интересный метод с неявням поведением, если есть строка в 
   которой слова разделены пробелами, применив к этой строке метод 
   split() и не передав никаких аргументов, мы получим слова строки в
   в списке, без каких либо пробелов, только элементы предложения по 
   существу, выглядит это след образом:
   
```python
    string = " Первый Второй  Третий   Четвертый  "
    print(string.split())

    # Вывод
    # Список из слов и только, ничего лишнего
    # ['Первый', 'Второй', 'Третий', 'Четвертый']
```
    
`string.split()` - этот способ удобен когда требуется получить список 
строк. 

Другой способ использовать эту функцию для разделение строки на список
из слов, это разбить строку по пробелу, `string.split(" ")` в таком 
случае в отдельные элементы будут выделены не только сами слова, но и 
каждый пробел в отдельности.

```python
    string = " Первый Второй  Третий   Четвертый  "
    print(string.split(" "))

    # Вывод
    # Список где каждый пробел превращается в собственный элемент
    # ['', 'Первый', 'Второй', '', 'Третий', '', '', 'Четвертый', '', '']
```

Этот способ может пригодиться когда нам необходимо знать количество 
пробелов как по бокам строки так и между строк.

---

Независимые функции для работы со строками
---
1) str() - превращает в строку переданную переменную
2) repr() - создает строковое представление переменной

```python
    var = 123
    print(repr(str(var)))
    print(repr(var))

    # Вывод
    # '123'
    # 123
```

---

Поиск подстроки в строке с нахождением индекса подстроки
---
Метод сроки `.find()` позволяет найти индекс первого вхождения подстроки в 
строке или возвращает -1.

```python
    string.find(substring,start,end)

    # substring: где искать
    # start: индес с которого начинать искать подстроку, по умолч это 0
    # end: индекс на котором перестать искать, по умолч это вся строка

    string = "Добро пожаловать!"
    print(string.find("о"))
   
    # Вывод
    # 1

    string = "Дбро пожаловать!"
    print(string.find("о"))

    # Вывод
    # 3
```

---

Поиск подстроки в строке без поиска индекса.
--- 
Если нам не интересен поиск индекса подстроки в строке, а интересует лишь 
находится ли подстрока или нет, тоетсь True или False то можно сделать это 
при помощи оператора `in` как и для поиска элемента в структурах данных.

```python
    string = 'Hi there'

    if 'Hi' in string:
        print('Да эта строка присутствует')
    else:
        print('Подстроки не найдено')
```

Этот способ не позволяет найти индекс вхождения, но лишь дает заключение есть 
она там или нет.

---

Методы строк
---

**Методы работы с регистром:**

`title()` - Каждый первый символ каждого слова переводит в верх регист

`capitalize()` - Первый символ строки в верх регистр

`swapcase()` - Меняет регистр символов местами

`upper()` - Переводит в верх регист все символы

`lower()` - Переводит в низ регист все символы

---

**Методы выравнивания:**

`rjust(20, '-')` - Выравнивает по правому краю, добавляет до 20 символов,
и эти пробелы заполняет указанным символом. 

`ljust(20, '-')` - Выравнивает по левому краю.

`center(20, '-')` - Выравнивает по центру.

---

**Методы удаления:**

Все три метода удаляют из строки указаную подстроку, с лева с права и
с обоих краев.

`lstrip('[]')`

`rstrip('[]')`

`strip('[]')`

---

**Разное**

`split()` - разбивает строчку на элементы и делает из них список, если 
ничего не передавать то разобьет по пробелу.

`",".join(list)` - соединяет все элементы списка в строчку, в которой 
каждый эллемент списка склеен при помощи указанного разделителя.

```python
    my_list = ['a','b','c','d','e']
    print(','.join(my_list))

    # Вывод
    # a,b,c,d,e
```

`startswith(str)` - Проверяет является ли указанная строка начальной 
подстракой строки.

`endswith(str)` - Тоже проверка но на окончание строки. 

Также на строки работает сравнение `in` и `not in` следующего типа:

```python
    str_1 = 'привет мир!'
    print(str_1, ' = ', 'привет' in str_1)

    str_2 = 'привет мир!'
    print(str_2, ' = ', 'привsdет' not in str_2)

    str_3 = 'привет мир!'
    print(str_3, ' = ', str_3.startswith('при'))

    str_4 = 'привет мир!'
    print(str_4, ' = ', str_4.endswith('мир!'))

    # Вывод
    # привет мир!  =  True
    # привет мир!  =  True
    # привет мир!  =  True
    # привет мир!  =  True
```

`find(str)` - Ищет подстрочку в строке и возвращает ее позицию, или 
если не найдена то -1.

`index(str)` - Схожа с превыдущей.

`replace(search, pattern)` - Ищет в строчке search и заменяет на pattern.  

---

Интернирование строк
---
Как помним для каждого обьекта хранятся не только его данные, но и счет 
количества ссылок на этот обьект, питон сам ведет подсчет ссылок на один и тот 
же обьект, если есть 2 строки то питон имеет только один обьект и 2 ссылки на 
него.

Этот механизм хорошо работает с числами:

```python
    print('\nid(2*3*3) == id(2*3*3) : ', id(2*3*3) == id(2*3*3))
    print('2*3*3 is 2*3*3 : ', 2*3*3 is 2*3*3)

    # Вывод
    # id(2*3*3) == id(2*3*3) :  True
    # 2*3*3 is 2*3*3 :  True
```

Что с обычными числами `555` , что с вычисляемыми значениями `2*3*3`
однако этот механизм работает иначе по отношению со строчками, две обычных 
строчки будут только в одном экземпляре и работать для них будет как обычно, 
но для вычисляемых строчек этот механизм не работает:

```python
    a1 = 'a'*40
    b1 = 'a'*40
    print('\nid(a1) == id(b1) : ', id(a1) == id(b1))
    print('a1 is b1 : ', a1 is b1)

    # Вывод
    # id(a1) == id(b1) :  False
    # a1 is b1 :  False
```

Механизм вычисления для строчек не работает, это будет 2 разных переенных.

---

Как быстрее вычислять строчки: + против .format
---

Надо использовать метод `.format()` в место канкатенации при помощи символа 
плюса `+` это требует гораздо меньше затрат, при канкатенации плючом, с начала
происходит создание временной строчки, потом новая канкатенация и создание 
новой временной строчки и так далее... это очень медлеено.

Метод format с начала определяет длинну строки и подставляет утда все символы,
по итогу получается быстрее.

---

У строк есть метод isnumeric isalpha isalnum
---

isnumeric - Метод возвращает True если в строке есть только числа.

isalpha - Возвр True если в строке только буквы

isalnum - Возвр True если в строке только числа + буквы

---

`isalnum()` - Метод принадлежит строчкам, проверяет являются ли все 
символы строки, буквами и числами если есть другие символы 
то возвращает False.

---

`capitalize()` - Переводит первый символ строки в верх регистр.

---

`str.swapcase()` - переключает регистр строки. 

